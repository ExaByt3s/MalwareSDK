#include <stdafx.h>

#include "..\common\binstorage.h"
#include "..\common\BinStorageEx.h"
#include "..\common\str.h"
#include "..\common\mem.h"
#include "..\common\fs.h"
#include "..\common\ucl.h"


#define SHF_REMOVED 0x1 


namespace BinStorage
{
	BinStorageEx::BinStorageEx() : binStorage(nullptr)
	{
		initialize();
	}

	BinStorageEx::~BinStorageEx()
	{
	}

	bool BinStorageEx::add(DWORD id, DWORD flags, void* data, DWORD dataSize)
	{
		return add_internal(binStorage, id, flags, data, dataSize);
	}

	bool BinStorageEx::add(DWORD id, DWORD flags, LPSTR string) 
	{
		bool r = false;
		Str::UTF8STRING u8s;

		if (Str::_utf8FromAnsi(string, -1, &u8s))
		{
			r = add(id, flags, u8s.data, u8s.size);
			Str::_utf8Free(&u8s);
		}

		return r;
	}

	bool BinStorageEx::add(DWORD id, DWORD flags, LPWSTR string) 
	{
		bool r = false;
		Str::UTF8STRING u8s;

		if (Str::_utf8FromUnicode(string, -1, &u8s))
		{
			r = add(id, flags, u8s.data, u8s.size);
			Str::_utf8Free(&u8s);
		}

		return r;
	}

	bool BinStorageEx::modify(DWORD itemID, DWORD flags, void* data, DWORD dataSize)
	{
		ITEM* item = nullptr;

		if ((item = get_item(binStorage, itemID, flags & ITEMF_IS_MASK)) != nullptr)
			return modify_internal(item, flags, data, dataSize);

		return false;
	}

	size_t BinStorageEx::size() const
	{
		if (binStorage != nullptr)
			return  binStorage->size;

		return 0;
	}

	size_t BinStorageEx::count() const
	{
		if (binStorage != nullptr)
			return  binStorage->count;

		return  -1;
	}

	ITEM* BinStorageEx::get_next_item(const STORAGE* binStorage, ITEM* current)
	{
		if (current == nullptr)
		{
			if (binStorage->count == 0 || binStorage->size < sizeof(STORAGE) + sizeof(ITEM))
				return nullptr;

			current = reinterpret_cast<ITEM *>(LPBYTE(binStorage) + sizeof(STORAGE));
		}
		else
		{
			current = (ITEM *)((LPBYTE)current + sizeof(ITEM) + current->size);
		}
			

		DWORD_PTR offset = (DWORD_PTR)((LPBYTE)current - (LPBYTE)binStorage) + sizeof(ITEM);
		
		if (offset <= binStorage->size && offset + current->size <= binStorage->size)
			return current;

		return nullptr;
	}

	ITEM* BinStorageEx::get_item(const STORAGE* binStorage, DWORD id, DWORD isFlag)
	{
		ITEM* cur = nullptr;

		while ((cur = get_next_item(binStorage, cur)) != nullptr)
			if (cur->id == id && isFlag == (cur->flags & ITEMF_IS_MASK))
				return cur;


		return nullptr;
	}

	bool BinStorageEx::modify_internal(ITEM* item, DWORD flags, void* data, DWORD dataSize)
	{
		DWORD itemOffset = static_cast<DWORD>(DWORD_PTR(item) - DWORD_PTR(binStorage));
		DWORD endOfItemOffset = itemOffset + sizeof(ITEM) + item->size;

		STORAGE* newBinStorage = nullptr;

		newBinStorage = new STORAGE[itemOffset];

		if (newBinStorage != nullptr)
		{
			mem::memcpy(newBinStorage, binStorage, itemOffset);

			newBinStorage->size = itemOffset;
			newBinStorage->count--;

			if (add_internal(newBinStorage, item->id, flags, data, dataSize))
			{
				DWORD copySize = (binStorage)->size - endOfItemOffset;
				if (copySize > 0 && mem::reallocEx(newBinStorage, newBinStorage->size + copySize))
				{
					mem::memcpy(LPBYTE(newBinStorage) + newBinStorage->size, LPBYTE(binStorage) + endOfItemOffset, copySize);
					newBinStorage->size += copySize;
					copySize = 0;
				}

				if (copySize == 0 && newBinStorage->size <= BINSTORAGE_MAX_SIZE)
				{
					mem::free(binStorage);
					binStorage = newBinStorage;
					return true;
				}
			}

			delete[]newBinStorage;
		}

		return false;
	}

	bool BinStorageEx::add_internal(STORAGE* binStorage, DWORD id, DWORD flags, void* data, DWORD dataSize)
	{

		DWORD newStorageSize = binStorage->size + sizeof(ITEM) + dataSize;
		if (newStorageSize > binStorage->size && id > 0 && mem::reallocEx(binStorage, newStorageSize))
		{
			STORAGE* p = binStorage;
			ITEM* item = reinterpret_cast<ITEM *>(LPBYTE(p) + p->size);
			LPBYTE dest = reinterpret_cast<LPBYTE>(item)+sizeof(ITEM);

			if (dataSize == 0)flags &= ~ITEMF_COMPRESSED;

			if (flags & ITEMF_COMPRESSED)
			{
				item->size = dataSize;
				int r = UCL::_Compress(LPBYTE(data), dataSize, dest, &item->size, nullptr, UCL::CF_NRV2B | UCL::CF_LEVEL_MAX);

				if (r == UCL::E_OUT_OF_BUFFER)
					flags &= ~ITEMF_COMPRESSED;

				else if (r != UCL::E_SUCCESSED)
					return false;
			}

			if ((flags & ITEMF_COMPRESSED) == 0)
			{
				item->size = dataSize;
				if (dataSize > 0)
					mem::memcpy(dest, data, dataSize);
			}

			DWORD fullItemSize = sizeof(ITEM) + item->size;
			if ((newStorageSize = p->size + fullItemSize) <= (10 * 1024 * 1024))
			{
				item->id = id;
				item->flags = flags;
				item->realSize = dataSize;

				p->size = newStorageSize;
				p->count++;
				return true;
			}
		}
		return false;
	}

	void BinStorageEx::initialize()
	{
		if (binStorage != nullptr)
			return;

		binStorage = (STORAGE*)mem::malloc(sizeof(STORAGE));
		binStorage->size = sizeof(STORAGE);
	}

	void BinStorageEx::resize_internal_count(size_t size) const
	{
		binStorage->count = size;
	}

	void BinStorageEx::reallocate(size_t size)
	{

		if (binStorage != nullptr && size > 0)
		{
			auto pS = new BinStorage::STORAGE[size];
			mem::memmove(pS, binStorage, size);
			delete[]binStorage;
			binStorage = pS;
			binStorage->size = size;
		}


	}


}
