#include "stdafx.h"
#include <winhttp.h>

#include "..\common\network\winhttp_wrapper.h"
#include "..\common\DynamicCall.h"
#include "mem.h"
#include "str.h"


HRESULT winhttp::WinhttpError()
{
	DWORD error_code = fpGetLastError();
	HRESULT hr = error_code != NO_ERROR ? CWA(kernel32, HRESULT_FROM_WIN32, error_code) : E_FAIL;
	return hr;
}

HRESULT winhttp::AddRequestHeaders(HINTERNET request, wchar_t* headers, int length, uint32_t modifiers)
{
	bool res = !!fpWinHttpAddRequestHeaders(request, headers, length, modifiers);
	return res ? S_OK : WinhttpError();
}

HRESULT winhttp::DetectAutoProxyConfigUrl(uint32_t flags, wchar_t* auto_config_url)
{
	wchar_t* url = nullptr;
	bool res = !!fpWinHttpDetectAutoProxyConfigUrl(flags, &url);

	HRESULT hr = res ? S_OK : WinhttpError();

	if (hr == S_OK && url != nullptr)
		mem::memcpy(auto_config_url, url, str::strlen(url) * sizeof(wchar_t));
	


	if (url != nullptr)
		fpGlobalFree(url);

	return hr;
}

HRESULT winhttp::GetDefaultProxyConfiguration(ProxyInfo* proxy_info)
{
	WINHTTP_PROXY_INFO pi = { 0 };
	bool res = !!fpWinHttpGetDefaultProxyConfiguration(&pi);

	proxy_info->access_type = pi.dwAccessType;
	proxy_info->proxy = pi.lpszProxy;
	proxy_info->proxy_bypass = pi.lpszProxyBypass;

	return res ? S_OK : WinhttpError();
}

HRESULT winhttp::GetProxyForUrl(HINTERNET session, const wchar_t* url, const AutoProxyOptions* proxy_options, ProxyInfo* proxy_info)
{
	WINHTTP_AUTOPROXY_OPTIONS apo = { 0 };
	apo.dwFlags = proxy_options->flags;
	apo.dwAutoDetectFlags = proxy_options->auto_detect_flags;
	apo.lpszAutoConfigUrl = proxy_options->auto_config_url;
	apo.lpvReserved = NULL;
	apo.dwReserved = 0;
	apo.fAutoLogonIfChallenged = proxy_options->auto_logon_if_challenged;

	WINHTTP_PROXY_INFO pi = { 0 };


	bool res = !!fpWinHttpGetProxyForUrl(session, url, &apo, &pi);

	proxy_info->access_type = pi.dwAccessType;
	proxy_info->proxy = pi.lpszProxy;
	proxy_info->proxy_bypass = pi.lpszProxyBypass;

	return res ? S_OK : WinhttpError();
}

HRESULT winhttp::Connect(HINTERNET session, const wchar_t* server, int port, HINTERNET* connection)
{
	// There has to be a valid session, otherwise it is possible that WinHTTP is
	// not properly initialized and the behavior of the WinHttpConnect is
	// undefined (it could crash in some cases).

	*connection = fpWinHttpConnect(session, server, static_cast<INTERNET_PORT>(port), 0);
	return *connection ? S_OK : WinhttpError();
}

HRESULT winhttp::Open(const wchar_t* user_agent, uint32_t access_type, const wchar_t* proxy_name, const wchar_t* proxy_bypass, DWORD flags, HINTERNET* session_handle)
{
	*session_handle = fpWinHttpOpen(user_agent, access_type, proxy_name, proxy_bypass, flags);
	return *session_handle ? S_OK : WinhttpError();
}

HRESULT winhttp::OpenRequest(HINTERNET connection, const wchar_t* verbose, const wchar_t* uri, const wchar_t* version, const wchar_t* referrer, const wchar_t** accept_types, uint32_t flags, HINTERNET* request_handle)
{
	*request_handle = fpWinHttpOpenRequest(connection, verbose, uri, version, referrer, accept_types, flags);
	return *request_handle ? S_OK : WinhttpError();
}

HRESULT winhttp::SendRequest(HINTERNET request_handle, const wchar_t* headers, DWORD headers_length, const void* optional_data, DWORD optional_data_length, DWORD content_length, DWORD_PTR context)
{
	bool res = fpWinHttpSendRequest(request_handle, headers, headers_length, const_cast<void*>(optional_data), optional_data_length, content_length, context);
	return res ? S_OK : WinhttpError();
}

HRESULT winhttp::ReceiveResponse(HINTERNET request_handle)
{
	bool res = !!fpWinHttpReceiveResponse(request_handle, nullptr);
	return res ? S_OK : WinhttpError();

}

HRESULT winhttp::CrackUrl(const wchar_t* url, uint32_t flags, wchar_t* scheme, wchar_t* server, int* port, wchar_t* url_path, wchar_t* extra_info)
{
	bool result = false;
	DWORD url_length = str::strlen(url);

	URL_COMPONENTS urlComp;


	mem::memset(&urlComp, 0, sizeof(urlComp));
	urlComp.dwStructSize = sizeof(urlComp);
	wchar_t szHostName[MAX_PATH] = L"";
	wchar_t szURLPath[MAX_PATH * 5] = L"";

	wchar_t szSchema[25 * 5] = L"";
	urlComp.dwStructSize = sizeof(urlComp);

	if (scheme)
	{
		urlComp.lpszScheme = szSchema;
		urlComp.dwSchemeLength = 25 + 5; // None zero
	}


	if (server)
	{
		urlComp.lpszHostName = szHostName;
		urlComp.dwHostNameLength = MAX_PATH;
	}

	if (url_path)
	{
		urlComp.lpszUrlPath = szURLPath;
		urlComp.dwUrlPathLength = MAX_PATH * 5;
	}




	// Crack the URL.
	if (fpWinHttpCrackUrl(url, DWORD(str::strlen(url)), DWORD(flags), &urlComp) != false)
	{
		result = true;
	}


	if (scheme)
	{
		scheme = urlComp.lpszScheme;
	}
	if (server)
	{
		server = urlComp.lpszHostName;
	}
	if (port)
	{
		*port = urlComp.nPort;
	}
	if (url_path)
	{
		url_path = urlComp.lpszUrlPath;
	}
	if (extra_info)
	{
		*extra_info = urlComp.lpszExtraInfo;
	}
	return result ? S_OK : WinhttpError();
}

HRESULT winhttp::SetOption(HINTERNET handle, uint32_t option, const void* buffer, DWORD length)
{

	bool res = !!fpWinHttpSetOption(handle, option, const_cast<void*>(buffer), length);
	return res ? S_OK : WinhttpError();
}

HRESULT winhttp::SetOptionInt(HINTERNET handle, uint32_t option, int value)
{
	return SetOptionT(handle, option, value);
}

HRESULT winhttp::QueryHeaders(HINTERNET request_handle, uint32_t info_level, const TCHAR* name, void* buffer, DWORD* buffer_length, DWORD* index)
{
	bool res = !!fpWinHttpQueryHeaders(request_handle, info_level, name, buffer, buffer_length, index);
	return res ? S_OK : WinhttpError();
}

HRESULT winhttp::QueryHeadersInt(HINTERNET request_handle, uint32_t info_level, const TCHAR* name, int* value, DWORD* index)
{
	info_level |= WINHTTP_QUERY_FLAG_NUMBER;
	DWORD value_size = sizeof(*value);
	HRESULT hr = QueryHeaders(request_handle, info_level, name, value, &value_size, index);

	if (FAILED(hr))  return hr;

	return S_OK;
}

HRESULT winhttp::QueryDataAvailable(HINTERNET request_handle, DWORD* num_bytes)
{
	HRESULT res = fpWinHttpQueryDataAvailable(request_handle, num_bytes);
	return res ? S_OK : WinhttpError();
}

HRESULT winhttp::ReadData(HINTERNET request_handle, void* buffer, DWORD buffer_length, DWORD* bytes_read)
{
	bool res = !!fpWinHttpReadData(request_handle, buffer, buffer_length, bytes_read);
	return res ? S_OK : WinhttpError();
}
