#pragma once

#include <common/base_types.h>
#include <common/mem.h>
#include <common/str_traits.h>
#include <common/string_fixed.h>


template <class T>
class BasicStringT
{
public:

	//////////////////////////////////////////////////////////////////////////
	// Types compatible with STL string.
	//////////////////////////////////////////////////////////////////////////

	typedef BasicStringT<T> _Self;
	typedef size_t size_type;
	typedef T value_type;
	typedef const value_type* const_str;
	typedef value_type* pointer;
	typedef const value_type* const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	typedef pointer iterator;
	typedef const_pointer const_iterator;

	//	typedef std::reverse_iterator<iterator>       reverse_iterator;
	//	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	static const size_type npos = size_type(-1);

	//////////////////////////////////////////////////////////////////////////
	// Constructors
	//////////////////////////////////////////////////////////////////////////
	BasicStringT();

	BasicStringT(const _Self& str);
	BasicStringT(const _Self& str, size_type nOff, size_type nCount);
	BasicStringT(size_type nRepeat, value_type value);
	BasicStringT(const_str str);
	BasicStringT(const_str str, size_type nLength);
	BasicStringT(const_iterator _First, const_iterator _Last);

	template<size_t AnySize>
	BasicStringT(const StackStringT<T, AnySize>& str);

	~BasicStringT();


protected:
	//	BasicStringT(const CConstCharWrapper& str); //!< Constructor for strings without memory allocations.
	//	friend class CConstCharWrapper;

public:
	//////////////////////////////////////////////////////////////////////////
	// STL string like interface.
	//////////////////////////////////////////////////////////////////////////
	//! Operators.
	size_type length() const;

	size_type size() const;

	bool empty() const;

	void clear(); //!< Frees the data.

	size_type capacity() const;

	
	void reserve(size_type nCount = 0);
	void shrink_to_fit();

	_Self& append(const value_type* lpString);
	_Self& append(const value_type* lpString, size_type nCount);
	_Self& append(const _Self& _Str, size_type nOff, size_type nCount);
	_Self& append(const _Self& _Str);
	_Self& append(size_type nCount, value_type value);
	_Self& append(const_iterator firts, const_iterator last);

	_Self& assign(const_str lpString);
	_Self& assign(const_str lpString, size_type nCount);
	_Self& assign(const _Self& _Str, size_type off, size_type nCount);
	_Self& assign(const _Self& _Str);
	_Self& assign(size_type nCount, value_type value);
	_Self& assign(const_iterator firts, const_iterator last);
	
	void swap(_Self& _Str) noexcept;

	///	operator=
	_Self& operator=(const _Self& str);
	_Self& operator=(value_type ch);
	_Self& operator=(const_str str);

	///	operator+=
	_Self& operator+=(const _Self& str);
	_Self& operator+=(value_type ch);
	_Self& operator+=(const_str str);

	value_type at(size_type index) const;

	const_reference front() const { return *begin(); }
	const_reference back() const { return *(end() - 1); }

	const_iterator begin() const { return m_str; }
	const_iterator cbegin() const { return begin(); }
	const_iterator end() const { return m_str + length(); }
	const_iterator cend() const { return end(); }

	//const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
	//const_reverse_iterator crbegin() const { return rbegin(); }
	//const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
	//const_reverse_iterator crend() const { return rend(); }

	//! cast to C string operator.
	operator const_str() const { return m_str; }

	//! cast to C string.
	const value_type* c_str() const { return m_str; }
	const value_type* data() const { return m_str; }

	//template<size_t AnySize> BasicStringT(const CryStackStringT<T, AnySize>& str);

protected:
	//! We prohibit an implicit conversion from CryStackString to make user aware of allocation!
	//! -> use string(stackedString) instead.
	/*

	template<size_t AnySize> _Self& operator=(const CryStackStringT<T, AnySize>& str)
	{
		// we add a compile-time error as the Visual C++ compiler seems to ignore the private statement?
		static_assert(AnySize != AnySize, "Use_Explicit_String_Assignment_When_Assigning_From_StackString");
		// not reached, as above will generate a compile time error
		_Assign(str.c_str(), str.length());
		return *this;
	}
	*/

protected:

	//! String header. Actual string data starts immediately after this header in memory.
	struct StrHeader
	{
		int nRefCount;
		int nLength;
		int nAllocSize; //!< Size of memory allocated at the end of this class.

		value_type* GetChars() { return (value_type*)(this + 1); }

		void AddRef()
		{
			nRefCount++; /*InterlockedIncrement(&_header()->nRefCount);*/
		}

		int Release() { return --nRefCount; }
	};

	static StrHeader* _emptyHeader()
	{
		// Define 2 static buffers in a row. The 2nd is a dummy object to hold a single empty char string.
		static StrHeader sEmptyStringBuffer[2] = {{-1, 0, 0},{0, 0, 0}};
		return &sEmptyStringBuffer[0];
	}

	// implementation helpers
	StrHeader* string_header() const;

	void allocate_internal(size_type nLen);
	static void free_data(StrHeader* pData);
	void free_internal();
	void initialize_internal();

	void concatenate_internal(const_str sStr1, size_type nLen1, const_str sStr2, size_type nLen2);
	void concatenate_in_place(const_str sStr, size_type nLen);
	void assign_internal(const_str sStr, size_type nLen);
	void make_unique();

	protected:
		value_type* m_str; //!< Pointer to ref counted string data.
};

template <class T>
typename BasicStringT<T>::value_type BasicStringT<T>::at(size_type index) const
{
	//assert(index >= 0 && index < length());
	return m_str[index];
}

template <class T>
BasicStringT<T>::BasicStringT()
{
	initialize_internal();
}

template <class T>
BasicStringT<T>::BasicStringT(const _Self& str)
{
	if (str.string_header()->nRefCount >= 0)
	{
		m_str = str.m_str;
		string_header()->AddRef();
	}
	else
	{
		initialize_internal();
	}
}

template <class T>
BasicStringT<T>::BasicStringT(const _Self& str, size_type offset, size_type count)
{
	initialize_internal();
	assign(str, offset, count);
}

template <class T>
BasicStringT<T>::BasicStringT(size_type nRepeat, value_type value)
{
	initialize_internal();
	if (nRepeat > 0)
	{
		allocate_internal(nRepeat);
		mem::memset(m_str, value, nRepeat);
	}
}

template <class T>
BasicStringT<T>::BasicStringT(const_str str)
{
	initialize_internal();

	size_type nLen = str::strlen(str);
	if (nLen != 0)
	{
		allocate_internal(nLen);
		mem::memcpy(m_str, str, nLen * sizeof(T));
	}
}

template <class T>
BasicStringT<T>::BasicStringT(const_str str, size_type nLength)
{
	initialize_internal();
	if (nLength > 0)
	{
		allocate_internal(nLength);
		mem::memcpy(m_str, str, nLength * sizeof(value_type));
	}
}

template <class T>
BasicStringT<T>::BasicStringT(const_iterator firt, const_iterator last)
{
	initialize_internal();

	size_type nLength = size_type(last - firt);

	if (nLength > 0)
	{
		allocate_internal(nLength);
		mem::memcpy(m_str, firt, nLength * sizeof(T));
	}
}

template <class T>
template <size_t AnySize>
BasicStringT<T>::BasicStringT(const StackStringT<T, AnySize>& str)
{
	initialize_internal();
	const size_type nLength = str.length();
	if (nLength > 0)
	{
		allocate_internal(nLength);
		mem::memcpy(m_str, str, nLength * sizeof(T));
	
	}
}

template <class T>
BasicStringT<T>::~BasicStringT()
{
	StrHeader * data = string_header();
	free_data(data);
}


template <class T>
typename BasicStringT<T>::size_type BasicStringT<T>::length() const
{
	return string_header()->nLength;
}


template <class T>
typename BasicStringT<T>::size_type BasicStringT<T>::size() const
{
	return string_header()->nLength;
}


template <class T>
bool BasicStringT<T>::empty() const
{
	return string_header()->nLength == 0;
}


template <class T>
typename BasicStringT<T>::size_type BasicStringT<T>::capacity() const
{
	return string_header()->nAllocSize;
}

template <class T>
void BasicStringT<T>::reserve(size_type nCount)
{
	if (nCount > capacity())
	{
		StrHeader* pOldData = string_header();
		allocate_internal(nCount);
		mem::memcpy(m_str, pOldData->GetChars(), pOldData->nLength * sizeof(T));
		string_header()->nLength = pOldData->nLength;
		m_str[pOldData->nLength] = 0;
		free_data(pOldData);
	}
	else if (nCount == 0)
	{
		shrink_to_fit();
	}
}

template <class T>
void BasicStringT<T>::shrink_to_fit()
{
	if (length() < capacity())
	{
		StrHeader* const pOldData = string_header();
		allocate_internal(length());
		mem::memcpy(m_str, pOldData->GetChars(), pOldData->nLength * sizeof(T));
		free_data(pOldData);
	}
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::append(const value_type* lpString)
{
	*this += lpString;
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::append(const value_type* lpString, size_type count)
{
	concatenate_in_place(lpString, count);
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::append(const _Self& _Str, size_type offset, size_type nCount)
{
	size_type len = _Str.length();
	if (offset > len)
		return *this;

	if (offset + nCount > len)
		nCount = len - offset;

	concatenate_in_place(_Str.m_str + offset, nCount);

	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::append(const _Self& _Str)
{
	*this += _Str;
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::append(size_type count, value_type value)
{
	if (count > 0)
	{
		if (string_header()->nRefCount > 1 || length() + count > capacity())
		{
			StrHeader* pOldData = string_header();
			allocate_internal(length() + count);
			mem::memcpy(m_str, pOldData->GetChars(), pOldData->nLength * sizeof(value_type));
			mem::memset(m_str + pOldData->nLength, value, count);
			free_data(pOldData);
		}
		else
		{
			size_type nOldLength = length();
			_set(m_str + nOldLength, value, count);
			string_header()->nLength = nOldLength + count;
			m_str[length()] = 0; // Make null terminated string.
		}
	}

	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::append(const_iterator firts, const_iterator last)
{
	append(firts, size_type(last - firts));
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::assign(const_str lpString)
{
	*this = lpString;
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::assign(const_str lpString, size_type count)
{
	size_type len = str::strnlen(lpString, count);
	assign_internal(lpString, len);
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::assign(const _Self& _Str, size_type off, size_type nCount)
{
	size_type len = _Str.length();

	if (off > len)
		return *this;

	if (off + nCount > len)
		nCount = len - off;

	assign_internal(_Str.m_str + off, nCount);
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::assign(const _Self& lpString)
{
	*this = lpString;
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::assign(size_type count, value_type value)
{
	if (count >= 1)
	{
		allocate_internal(count);
		mem::memset(m_str, value, count);
	}
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::assign(const_iterator firts, const_iterator last)
{
	assign(firts, (size_type)(firts - last));
	return *this;
}

template <class T>
void BasicStringT<T>::swap(_Self& _Str) noexcept
{
	value_type* temp = _Str.m_str;
	_Str.m_str = m_str;
	m_str = temp;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::operator=(const _Self& str)
{
	if (m_str != str.m_str)
	{
		if (string_header()->nRefCount < 0)
		{
			if (str.string_header()->nRefCount < 0)
				bool empy = true; // two empty strings...
			else
			{
				m_str = str.m_str;
				string_header()->AddRef();
			}
		}
		else if (str.string_header()->nRefCount < 0)
		{
			free_internal();
			m_str = str.m_str;
		}
		else
		{
			free_internal();
			m_str = str.m_str;
			string_header()->AddRef();
		}
	}
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::operator=(value_type ch)
{
	assign_internal(&ch, 1);
	return *this;
}

template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::operator=(const_str str)
{
	assign_internal(str, str::strlen(str));
	return *this;
}


template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::operator+=(const _Self& str)
{
	concatenate_in_place(str.m_str, str.length());
	return *this;
}


template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::operator+=(value_type value)
{
	concatenate_in_place(&value, 1);
	return *this;
}


template <class T>
typename BasicStringT<T>::_Self& BasicStringT<T>::operator+=(const_str str)
{
	concatenate_in_place(str, str::strlen(str));
	return *this;
}


template <class T>
typename BasicStringT<T>::StrHeader* BasicStringT<T>::string_header() const
{
	//assert(m_str != NULL);
	return ((StrHeader*)m_str) - 1;
}


template <class T>
void BasicStringT<T>::allocate_internal(size_type nLen)
{
	if (nLen == 0)
		initialize_internal();
	else
	{
		size_type allocLen = sizeof(StrHeader) + (nLen + 1) * sizeof(value_type);

		StrHeader* pData = new StrHeader[allocLen];
		pData->nRefCount = 1;
		m_str = pData->GetChars();
		pData->nLength = nLen;
		pData->nAllocSize = nLen;

		//check_convert(pData->nLength) = nLen;
		//check_convert(pData->nAllocSize) = nLen;
		m_str[nLen] = 0; // null terminated string.
	}
}


template <class T>
void BasicStringT<T>::free_data(StrHeader* pData)
{
	if (pData->nRefCount >= 0) // Not empty string.
	{
		//assert(pData->nRefCount != 0);
		if (pData->Release() <= 0)
		{
			size_t allocLen = sizeof(StrHeader) + (pData->nAllocSize + 1) * sizeof(value_type);
			StrHeader* old_data = pData;
			delete[]old_data;
		}
	}
}


template <class T>
void BasicStringT<T>::free_internal()
{
	if (string_header()->nRefCount >= 0) // Not empty string.
	{
		free_data(string_header());
		initialize_internal();
	}
}


template <class T>
void BasicStringT<T>::initialize_internal()
{
	m_str = _emptyHeader()->GetChars();
}


template <class T>
void BasicStringT<T>::concatenate_internal(const_str sStr1, size_type nLen1, const_str sStr2, size_type nLen2)
{
	size_type nLen = nLen1 + nLen2;

	if (nLen1 * 2 > nLen) nLen = nLen1 * 2;
	if (nLen != 0)
	{
		if (nLen < 8)
			nLen = 8;

		allocate_internal(nLen);
		mem::memcpy(m_str, sStr1, nLen1 * sizeof(value_type));
		mem::memcpy(m_str + nLen1, sStr2, nLen2 * sizeof(value_type));
		string_header()->nLength = nLen1 + nLen2;
		m_str[nLen1 + nLen2] = 0;
	}
}


template <class T>
void BasicStringT<T>::concatenate_in_place(const_str sStr, size_type nLen)
{
	if (nLen != 0)
	{
		if (string_header()->nRefCount > 1 || length() + nLen > capacity())
		{
			StrHeader* pOldData = string_header();
			concatenate_internal(m_str, length(), sStr, nLen);
			free_data(pOldData);
		}
		else
		{
			mem::memcpy(m_str + length(), sStr, nLen * sizeof(value_type));
			string_header()->nLength = string_header()->nLength + nLen;
			m_str[string_header()->nLength] = 0;
		}
	}
}


template <class T>
void BasicStringT<T>::assign_internal(const_str sStr, size_type nLen)
{
	// Then allocate new string buffer.
	if (string_header()->nRefCount > 1 || nLen > capacity())
	{
		free_internal();
		allocate_internal(nLen);
	}

	mem::memcpy(m_str, sStr, nLen * sizeof(value_type));
	//check_convert(_header()->nLength) = nLen;
	string_header()->nLength = nLen;
	m_str[nLen] = 0;
}


template <class T>
void BasicStringT<T>::make_unique()
{
	if (string_header()->nRefCount > 1)
	{
		// If string is shared, make a copy of string buffer.
		StrHeader* pOldData = string_header();
		// This will not free header because reference count is greater then 1.
		free_internal();
		// Allocate a new string buffer.
		allocate_internal(pOldData->nLength);
		size_type bytes = pOldData->nLength + 1;

		mem::memcpy(m_str, pOldData->GetChars(), bytes * sizeof(value_type));
	}
}


//////////////////////////////////////////////////////////////////////////
//! compare helpers
template<class T> inline bool operator==(const BasicStringT<T>& s1, const BasicStringT<T>& s2)
{
	return s1.compare(s2) == 0;
}
template<class T> inline bool operator==(const BasicStringT<T>& s1, const typename BasicStringT<T>::value_type* s2)
{
	return s1.compare(s2) == 0;
}
template<class T> inline bool operator==(const typename BasicStringT<T>::value_type* s1, const BasicStringT<T>& s2)
{
	return s2.compare(s1) == 0;
}
template<class T> inline bool operator!=(const BasicStringT<T>& s1, const BasicStringT<T>& s2)
{
	return s1.compare(s2) != 0;
}
template<class T> inline bool operator!=(const BasicStringT<T>& s1, const typename BasicStringT<T>::value_type* s2)
{
	return s1.compare(s2) != 0;
}
template<class T> inline bool operator!=(const typename BasicStringT<T>::value_type* s1, const BasicStringT<T>& s2)
{
	return s2.compare(s1) != 0;
}
template<class T> inline bool operator<(const BasicStringT<T>& s1, const BasicStringT<T>& s2)
{
	return s1.compare(s2) < 0;
}
template<class T> inline bool operator<(const BasicStringT<T>& s1, const typename BasicStringT<T>::value_type* s2)
{
	return s1.compare(s2) < 0;
}
template<class T> inline bool operator<(const typename BasicStringT<T>::value_type* s1, const BasicStringT<T>& s2)
{
	return s2.compare(s1) > 0;
}
template<class T> inline bool operator>(const BasicStringT<T>& s1, const BasicStringT<T>& s2)
{
	return s1.compare(s2) > 0;
}
template<class T> inline bool operator>(const BasicStringT<T>& s1, const typename BasicStringT<T>::value_type* s2)
{
	return s1.compare(s2) > 0;
}
template<class T> inline bool operator>(const typename BasicStringT<T>::value_type* s1, const BasicStringT<T>& s2)
{
	return s2.compare(s1) < 0;
}
template<class T> inline bool operator<=(const BasicStringT<T>& s1, const BasicStringT<T>& s2)
{
	return s1.compare(s2) <= 0;
}
template<class T> inline bool operator<=(const BasicStringT<T>& s1, const typename BasicStringT<T>::value_type* s2)
{
	return s1.compare(s2) <= 0;
}
template<class T> inline bool operator<=(const typename BasicStringT<T>::value_type* s1, const BasicStringT<T>& s2)
{
	return s2.compare(s1) >= 0;
}
template<class T> inline bool operator>=(const BasicStringT<T>& s1, const BasicStringT<T>& s2)
{
	return s1.compare(s2) >= 0;
}
template<class T> inline bool operator>=(const BasicStringT<T>& s1, const typename BasicStringT<T>::value_type* s2)
{
	return s1.compare(s2) >= 0;
}
template<class T> inline bool operator>=(const typename BasicStringT<T>::value_type* s1, const BasicStringT<T>& s2)
{
	return s2.compare(s1) <= 0;
}

typedef BasicStringT<char> string;
typedef BasicStringT<wchar_t> wstring;