#pragma once


class MemDataStream
{
public:

	MemDataStream(int sz = 0);

	~MemDataStream();

	operator void*() const;

	operator char*() const;

	operator unsigned char*() const; // BYTE

	bool MakeEnough(int sz);

	int length() const;
	int set_length(int sz);
	int add_length(int add);

	int size() const;

	bool append(const void* ptr, int c_ptr);

	bool append(const char* s, int c_s = -1);

	bool IsEnough(int sz);

	void* ptr_write(); //El comienzo de la memoria libre donde puedes escribir datos.

	void clear();

	void set_full(char c);

	int find_firts_of(int start, const void* what, int c_what);

	int find_firts_of(int start, char c);

	int find_firts_of(const void* what, int c_what);

	void find_sub_mem(int index, int len = INT_MAX);

	void find_sub_mem(MemDataStream& mem, int index, int len = INT_MAX);

	bool insert(int index, const void* ptr, int c_ptr);

	bool insert(int index, const MemDataStream& data);

	void remove(int index, int len);

	void left(int n);

	void Right(int n);

	void delete_left(int n);

	void delete_right(int n);

	int copy(const void* src, int c_src);

	int copy(const MemDataStream& src);

	int copy(int dst_start, int src_start, int count, const void* src, int c_src); //aquí la longitud de la memoria
																					//llena permanecerá igual o aumentará si dst_start + c_src es mayor
	int copy(int start, const void* src, int c_src);

	int copy(int dst_start, int src_start, int count, const MemDataStream& src);

	int copy(int dst_start, int src_start, const MemDataStream& src);

	//string& ToString(string& s);

	//	desbvincula la memoria asignada de este objeto para que no se elimine en el destructor.
	//	Devuelve un puntero a la desvinculada.
	void* unlink();

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//	conecta los datos de otros Datos, es necesario llamar la función unlink después,
	//	de lo contrario se eliminará dos veces la matriz de datos.
	//
	// los Datos actuales deben estar vacíos (justo después del constructor de Datos () o después de Desvincular),
	// de lo contrario puede producirse una pérdida de memoria
	//
	// Además, en ningún caso debe haber una reasignación de memoria.
	//
	// Solo se debe usar link si los datos enlazados no cambian

	void link(MemDataStream& src);

	void link(void* _data, int _c_data);

	int replace(void* lpData, int count1, void* lpData2, int count2);

	bool reallocate(int sz);
private:
	MemDataStream(const MemDataStream&);
	int find_index(const void* ptr, int c_ptr, const void* what, int c_what);
	int find_index(const void* ptr, char c, int c_ptr);
private:
	void* data; 
	int c_data; 
	int sz_data; 
};
