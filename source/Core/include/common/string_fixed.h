#pragma once

#include <common/mem.h>
#include <common/str_traits.h>



//https://github.com/zfa07/Killyouss/blob/2bdd5ae2a43c3cfadd9a745345d1b4e1899e4535/Engine/Source/ThirdParty/nvTextureTools/nvTextureTools-2.0.8/src/src/nvcore/StrLib.h
//https://github.com/vztpv/StringBuilder/blob/992552f4598812c396225917cd083a83be0accbb/main.cpp


template <class T, size_t S>
class StackStringT
{
public:
	//////////////////////////////////////////////////////////////////////////
	// Types compatible with STL string.
	//////////////////////////////////////////////////////////////////////////
	typedef StackStringT<T, S> _Self;
	typedef size_t size_type;
	typedef T value_type;
	typedef const value_type* const_str;
	typedef value_type* pointer;
	typedef const value_type* const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	typedef pointer iterator;
	typedef const_pointer const_iterator;
	static const size_type MAX_SIZE = S;

	static const size_type npos = size_type(-1);


public:
	//////////////////////////////////////////////////////////////////////////
	// Constructors
	//////////////////////////////////////////////////////////////////////////
	StackStringT();

	StackStringT(const _Self& str);
	StackStringT(const _Self& str, size_type nOff, size_type nCount);
	StackStringT(size_type nRepeat, value_type ch);
	StackStringT(const_str str);
	//StackStringT(const BasicStringT<T>& str);
	StackStringT(const_str str, size_type nLength);
	StackStringT(const_iterator _First, const_iterator _Last);
	~StackStringT();

	//////////////////////////////////////////////////////////////////////////
	// STL string like interface.
	//////////////////////////////////////////////////////////////////////////
	//! Operators.
	size_type length() const;
	size_type size() const;
	bool empty() const;
	void clear(); //!< Free up the data.

	//! Returns the storage currently allocated to hold the string, a value at least as large as length().
	//! Also: capacity is always >= (MAX_SIZE-1).
	size_type capacity() const;

	//! Sets the capacity of the string to a number at least as great as a specified number.
	//! Shrink to fit post-cond: capacity() >= (MAX_SIZE-1).
	//! \param nCount = 0 is shrinking string to fit number of characters in it.
	void reserve(size_type nCount = 0);

	///
	_Self& append(const value_type* lpString);
	_Self& append(const value_type* lpString, size_type nCount);
	_Self& append(const _Self& _Str, size_type nOff, size_type nCount);
	_Self& append(const _Self& _Str);
	_Self& append(size_type nCount, value_type _Ch);
	_Self& append(const_iterator _First, const_iterator _Last);

	///
	_Self& assign(const_str lpString);
	_Self& assign(const_str lpString, size_type nCount);
	_Self& assign(const _Self& _Str, size_type off, size_type nCount);
	_Self& assign(const _Self& _Str);
	_Self& assign(size_type nCount, value_type _Ch);
	_Self& assign(const_iterator _First, const_iterator _Last);

	value_type at(size_type index) const;


	const_iterator begin() const { return m_str; };
	const_iterator end() const { return m_str + length(); };

	iterator begin() { return m_str; };
	iterator end() { return m_str + length(); };

	//! cast to C string operator.
	operator const_str() const { return m_str; }

	//! cast to C string.
	const value_type* c_str() const { return m_str; }
	const value_type* data() const { return m_str; };


	//////////////////////////////////////////////////////////////////////////
	// overloaded operators.
	//////////////////////////////////////////////////////////////////////////

	value_type operator[](size_type index) const;

	_Self& operator=(const _Self& str);
	_Self& operator=(value_type ch);
	_Self& operator=(const_str str);
	//_Self& operator=(const BasicStringT<T>& str);


	// string concatenation
	_Self& operator+=(const _Self& str);
	_Self& operator+=(value_type ch);
	_Self& operator+=(const_str str);
	//_Self& operator+=(const BasicStringT<T>& str);


	int compare(const _Self& _Str) const;
	int compare(size_type offset, size_type count1, const _Self& _Str) const;
	int compare(size_type offet1, size_type count1, const _Self& _Str, size_type offset2, size_type count2) const;
	int compare(const value_type* _Ptr) const;
	int compare(size_type offset, size_type count, const value_type* _Ptr, size_type second = npos) const;


	size_t GetAllocatedMemory() const
	{
		size_t size = sizeof(*this);
		if (m_str != m_strBuf)
			size += (m_nAllocSize + 1) * sizeof(value_type);
		return size;
	}


public:
	size_type m_nLength;
	size_type m_nAllocSize;
	value_type* m_str; //!< Pointer to ref counted string data.
	value_type m_strBuf[MAX_SIZE];

	// implementation helpers
	void _AllocData(size_type nLen);
	void _FreeData(value_type* pData);
	void _Free();
	void _Initialize();

	void _Concatenate(const_str sStr1, size_type nLen1, const_str sStr2, size_type nLen2);
	void _ConcatenateInPlace(const_str sStr, size_type nLen);
	void _Assign(const_str sStr, size_type nLen);
	//void _MakeUnique();
};

template <class T, size_t S>
typename StackStringT<T, S>::value_type StackStringT<T, S>::at(size_type index) const
{
	return m_str[index];
}

template <class T, size_t S>
typename StackStringT<T, S>::size_type StackStringT<T, S>::length() const
{
	return m_nLength;
}

template <class T, size_t S>
typename StackStringT<T, S>::size_type StackStringT<T, S>::size() const
{
	return m_nLength;
}

template <class T, size_t S>
bool StackStringT<T, S>::empty() const
{
	return m_nLength == 0;
}

template <class T, size_t S>
void StackStringT<T, S>::clear()
{
	if (m_nLength == 0) return;

	_Free();

	//assert(m_nLength== 0);
}

template <class T, size_t S>
StackStringT<T, S>::StackStringT()
{
	_Initialize();
}

template <class T, size_t S>
StackStringT<T, S>::StackStringT(const _Self& str)
{
	_Initialize();
	_Assign(str.c_str(), str.length());
}

template <class T, size_t S>
StackStringT<T, S>::StackStringT(const _Self& str, size_type nOff, size_type nCount)
{
	_Initialize();
	assign(str, nOff, nCount);
}

template <class T, size_t S>
StackStringT<T, S>::StackStringT(size_type nRepeat, value_type ch)
{
	_Initialize();
	if (nRepeat > 0)
	{
		_AllocData(nRepeat);
		mem::memset(m_str, ch, nRepeat);
	}
}

template <class T, size_t S>
StackStringT<T, S>::StackStringT(const_str str)
{
	_Initialize();
	// Make a copy of C string.
	size_type nLen = str::strlen(str);
	if (nLen != 0)
	{
		_AllocData(nLen);
		mem::memcpy(m_str, str, nLen * sizeof(T));
	}
}

template <class T, size_t S>
StackStringT<T, S>::StackStringT(const_str str, size_type nLength)
{
	_Initialize();

	if (nLength > 0)
	{
		_AllocData(nLength);
		mem::memcpy(m_str, str, nLength * sizeof(T));
	}
}

template <class T, size_t S>
StackStringT<T, S>::StackStringT(const_iterator _First, const_iterator _Last)
{
	_Initialize();
	size_type nLength = size_type(_Last - _First);

	if (nLength > 0)
	{
		_AllocData(nLength);
		mem::memcpy(m_str, _First, nLength * sizeof(T));
	}
}

template <class T, size_t S>
StackStringT<T, S>::~StackStringT()
{
}

template <class T, size_t S>
typename StackStringT<T, S>::size_type StackStringT<T, S>::capacity() const
{
	return m_nAllocSize;
}

template <class T, size_t S>
void StackStringT<T, S>::reserve(size_type nCount)
{
	// Reserve of 0 is shrinking container to fit number of characters in it..
	if (nCount > m_nAllocSize)
	{
		value_type* pOldData = m_str;
		size_type nOldLength = m_nLength;
		_AllocData(nCount);
		mem::memcpy(m_str, pOldData, nOldLength * sizeof(value_type));
		m_nLength = nOldLength;
		m_str[m_nLength] = 0;
		_FreeData(pOldData);
	}
	else if (nCount == 0)
	{
		if (length() != m_nAllocSize)
		{
			value_type* pOldData = m_str;
			if (pOldData != m_strBuf)
			{
				size_type nOldLength = m_nLength;
				_AllocData(m_nLength);

				mem::memcpy(m_str, pOldData, nOldLength * sizeof(value_type));
				_FreeData(pOldData);
			}
		}
	}
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::append(const value_type* lpString)
{
	*this += lpString;
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::append(const value_type* lpString, size_type nCount)
{
	_ConcatenateInPlace(lpString, nCount);
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::append(const _Self& _Str, size_type nOff, size_type nCount)
{
	size_type len = _Str.length();

	if (nOff > len)
		return *this;

	if (nOff + nCount > len)
		nCount = len - nOff;

	_ConcatenateInPlace(_Str.m_str + nOff, nCount);
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::append(const _Self& _Str)
{
	*this += _Str;
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::append(size_type nCount, value_type _Ch)
{
	if (nCount > 0)
	{
		if (m_nLength + nCount >= m_nAllocSize)
		{
			value_type* old_data = m_str;
			size_type old_length = m_nLength;
			_AllocData(m_nLength + nCount);
			mem::memcpy(m_str, old_data, old_length * sizeof(value_type));
			mem::memset(m_str + old_length, _Ch, nCount);
			_FreeData(old_data);
		}
		else
		{
			size_type old_length = m_nLength;
			mem::memset(m_str + old_length, _Ch, nCount);
			m_nLength = old_length + nCount;
			m_str[m_nLength] = 0;
		}
	}
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::append(const_iterator _First, const_iterator _Last)
{
	append(_First, size_type(_Last - _First));
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::assign(const_str lpString)
{
	*this = lpString;
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::assign(const_str lpString, size_type nCount)
{
	size_type len = str::strlen(lpString);
	_Assign(lpString, (nCount < len) ? nCount : len);
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::assign(const _Self& _Str, size_type off, size_type nCount)
{
	size_type len = _Str.length();

	if (off > len)
		return *this;
	if (off + nCount > len)
		nCount = len - off;

	_Assign(_Str.m_str + off, nCount);
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::assign(const _Self& _Str)
{
	*this = _Str;
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::assign(size_type nCount, value_type _Ch)
{
	if (nCount >= 1)
	{
		_AllocData(nCount);
		mem::memset(m_str, _Ch, nCount);
	}

	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::assign(const_iterator _First, const_iterator _Last)
{
	assign(_First, size_type(_Last - _First));
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::value_type StackStringT<T, S>::operator[](size_type index) const
{
	//assert(index < m_nLength);

	return m_str[index];
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::operator=(const _Self& str)
{
	_Assign(str.c_str(), str.length());
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::operator=(value_type ch)
{
	_Assign(&ch, 1);
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::operator=(const_str str)
{
	_Assign(str, str::strlen(str));
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::operator+=(const _Self& str)
{
	_ConcatenateInPlace(str.c_str(), str.size());
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::operator+=(value_type ch)
{
	_ConcatenateInPlace(&ch, 1);
	return *this;
}

template <class T, size_t S>
typename StackStringT<T, S>::_Self& StackStringT<T, S>::operator+=(const_str str)
{
	//assert(str == NULL || is_valid_string(str));
	_ConcatenateInPlace(str, str::strlen(str));
	return *this;
}

template <class T, size_t S>
int StackStringT<T, S>::compare(const _Self& _Str) const
{
	return str::strcmp(m_str, _Str.m_str);
}

template <class T, size_t S>
int StackStringT<T, S>::compare(size_type offet1, size_type count1, const _Self& _Str) const
{
	return compare(offet1, count1, _Str.m_str, npos);
}

template <class T, size_t S>
int StackStringT<T, S>::compare(size_type offet1, size_type count1, const _Self& _Str, size_type offset2, size_type count2) const
{
	return compare(offet1, count1, _Str.m_str + offset2, count2);
}

template <class T, size_t S>
int StackStringT<T, S>::compare(const value_type* _Ptr) const
{
	return str::strcmp(m_str, _Ptr);
}

template <class T, size_t S>
int StackStringT<T, S>::compare(size_type offset, size_type count1, const value_type* lpString, size_type count2) const
{
	if (length() - offset < count1)
		count1 = length() - offset;

	int res = count1 == 0 ? 0 : str::strncmp(m_str + offset, lpString, (count1 < count2) ? count1 : count2);
	return (res != 0 ? res : count2 == npos && lpString[count1] == 0 ? 0 : count1 < count2 ? -1 : count1 == count2 ? 0 : +1);
}

template <class T, size_t S>
void StackStringT<T, S>::_AllocData(size_type nLen)
{
	//assert(nLen >= 0);
	//assert(nLen <= INT_MAX - 1);    // max size (enough room for 1 extra)

	if (nLen == 0)
	{
		_Initialize();
	}

	else
	{
		size_type allocLen = (nLen + 1) * sizeof(value_type);
		value_type* pData = m_strBuf;
		if (allocLen > MAX_SIZE)
		{
			pData = new value_type[allocLen];
			m_nAllocSize = nLen;
		}
		else
		{
			m_nAllocSize = MAX_SIZE - 1;
		}
		m_nLength = nLen;
		m_str = pData;
		m_str[nLen] = 0; // null terminated string.
	}
}

template <class T, size_t S>
void StackStringT<T, S>::_FreeData(value_type* pData)
{
	if (pData != m_strBuf)
	{
		size_t allocLen = (m_nAllocSize + 1) * sizeof(value_type);
		delete[]pData;
	}
}

template <class T, size_t S>
void StackStringT<T, S>::_Free()
{
	_FreeData(m_str);
	_Initialize();
}

template <class T, size_t S>
void StackStringT<T, S>::_Initialize()
{
	m_strBuf[0] = 0;
	m_str = m_strBuf;
	m_nLength = 0;
	m_nAllocSize = MAX_SIZE - 1; // 0 termination not counted!
}

template <class T, size_t S>
void StackStringT<T, S>::_Concatenate(const_str sStr1, size_type nLen1, const_str sStr2, size_type nLen2)
{
	size_type nLen = nLen1 + nLen2;
	if (nLen1 * 2 > nLen)
		nLen = nLen1 * 2;
	if (nLen != 0)
	{
		if (nLen < 8) nLen = 8;
		_AllocData(nLen);
		mem::memcpy(m_str, sStr1, nLen1 * sizeof(value_type));
		mem::memcpy(m_str + nLen1, sStr2, nLen2 * sizeof(value_type));
		m_nLength = nLen1 + nLen2;
		m_str[nLen1 + nLen2] = 0;
	}
}

template <class T, size_t S>
void StackStringT<T, S>::_ConcatenateInPlace(const_str sStr, size_type nLen)
{
	if (nLen != 0)
	{
		// Check if this string is shared (reference count greater then 1) or not enough capacity to store new string.
		// Then allocate new string buffer.
		if (length() + nLen > capacity())
		{
			value_type* pOldData = m_str;
			_Concatenate(m_str, length(), sStr, nLen);
			_FreeData(pOldData);
		}
		else
		{
			mem::memcpy(m_str + length(), sStr, nLen * sizeof(value_type));
			m_nLength += nLen;
			m_str[m_nLength] = 0; // Make null terminated string.
		}
	}
}

template <class T, size_t S>
void StackStringT<T, S>::_Assign(const_str sStr, size_type nLen)
{
	if (nLen > capacity())
	{
		_Free();
		_AllocData(nLen);
	}

	mem::memcpy(m_str, sStr, nLen * sizeof(T));
	m_nLength = nLen;
	m_str[nLen] = 0;
}

///////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//! compare helpers
template <class T, size_t S>
inline bool operator==(const StackStringT<T, S>& s1, const StackStringT<T, S>& s2)
{
	return s1.compare(s2) == 0;
}

template <class T, size_t S>
inline bool operator==(const StackStringT<T, S>& s1, const typename StackStringT<T, S>::value_type* s2)
{
	return s1.compare(s2) == 0;
}

template <class T, size_t S>
inline bool operator==(const typename StackStringT<T, S>::value_type* s1, const StackStringT<T, S>& s2)
{
	return s2.compare(s1) == 0;
}

template <class T, size_t S>
inline bool operator!=(const StackStringT<T, S>& s1, const StackStringT<T, S>& s2)
{
	return s1.compare(s2) != 0;
}

template <class T, size_t S>
inline bool operator!=(const StackStringT<T, S>& s1, const typename StackStringT<T, S>::value_type* s2)
{
	return s1.compare(s2) != 0;
}

template <class T, size_t S>
inline bool operator!=(const typename StackStringT<T, S>::value_type* s1, const StackStringT<T, S>& s2)
{
	return s2.compare(s1) != 0;
}

template <class T, size_t S>
inline bool operator<(const StackStringT<T, S>& s1, const StackStringT<T, S>& s2)
{
	return s1.compare(s2) < 0;
}

template <class T, size_t S>
inline bool operator<(const StackStringT<T, S>& s1, const typename StackStringT<T, S>::value_type* s2)
{
	return s1.compare(s2) < 0;
}

template <class T, size_t S>
inline bool operator<(const typename StackStringT<T, S>::value_type* s1, const StackStringT<T, S>& s2)
{
	return s2.compare(s1) > 0;
}

template <class T, size_t S>
inline bool operator>(const StackStringT<T, S>& s1, const StackStringT<T, S>& s2)
{
	return s1.compare(s2) > 0;
}

template <class T, size_t S>
inline bool operator>(const StackStringT<T, S>& s1, const typename StackStringT<T, S>::value_type* s2)
{
	return s1.compare(s2) > 0;
}

template <class T, size_t S>
inline bool operator>(const typename StackStringT<T, S>::value_type* s1, const StackStringT<T, S>& s2)
{
	return s2.compare(s1) < 0;
}

template <class T, size_t S>
inline bool operator<=(const StackStringT<T, S>& s1, const StackStringT<T, S>& s2)
{
	return s1.compare(s2) <= 0;
}

template <class T, size_t S>
inline bool operator<=(const StackStringT<T, S>& s1, const typename StackStringT<T, S>::value_type* s2)
{
	return s1.compare(s2) <= 0;
}

template <class T, size_t S>
inline bool operator<=(const typename StackStringT<T, S>::value_type* s1, const StackStringT<T, S>& s2)
{
	return s2.compare(s1) >= 0;
}

template <class T, size_t S>
inline bool operator>=(const StackStringT<T, S>& s1, const StackStringT<T, S>& s2)
{
	return s1.compare(s2) >= 0;
}

template <class T, size_t S>
inline bool operator>=(const StackStringT<T, S>& s1, const typename StackStringT<T, S>::value_type* s2)
{
	return s1.compare(s2) >= 0;
}

template <class T, size_t S>
inline bool operator>=(const typename StackStringT<T, S>::value_type* s1, const StackStringT<T, S>& s2)
{
	return s2.compare(s1) <= 0;
}



//////////////////////////////////////////////////////

template <size_t S>
class StringBuilderStackT : public StackStringT<char, S>
{
public:
	typedef StackStringT<char, S> _parentType;
	typedef StringBuilderStackT<S> _Self;
	typedef size_t size_type;
	typedef char value_type;
	typedef const value_type* const_str;
	typedef value_type* pointer;
	typedef const value_type* const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	typedef pointer iterator;
	typedef const_pointer const_iterator;
	static const size_type MAX_SIZE = S;

	StringBuilderStackT() : _parentType()
	{
	}

	StringBuilderStackT(const _parentType& str) : _parentType(str)
	{
	}

	StringBuilderStackT(const _parentType& str, size_type nOff, size_type nCount) : _parentType(str, nOff, nCount)
	{
	}

	StringBuilderStackT(const _Self& str) : _parentType(str)
	{
	}

	StringBuilderStackT(const _Self& str, size_type nOff, size_type nCount) : _parentType(str, nOff, nCount)
	{
	}

	StringBuilderStackT(size_type nRepeat, value_type ch) : _parentType(nRepeat, ch)
	{
	}

	StringBuilderStackT(const_str str) : _parentType(str)
	{
	}

	StringBuilderStackT(const_str str, size_type nLength) : _parentType(str, nLength)
	{
	}

	StringBuilderStackT(const_iterator _First, const_iterator _Last) : _parentType(_First, _Last)
	{
	}

	template <size_t AnySize>
	_Self& operator=(const StringBuilderStackT<AnySize>& str)
	{
		_parentType::operator=(str);

		return *this;
	}

	template <size_t AnySize>
	_Self& operator=(const StackStringT<char, AnySize>& str)
	{
		_parentType::operator=(str);
		return *this;
	}

	_Self& operator=(value_type ch)
	{
		_parentType::operator=(ch);

		return *this;
	}
};

/////////////////////////////////////////////////////

//! A template specialization for wchar_t.
template <size_t S>
class StringBuilderStackWT : public StackStringT<wchar_t, S>
{
public:
	typedef StackStringT<wchar_t, S> _parentType;
	typedef StringBuilderStackWT<S> _Self;
	typedef size_t size_type;
	typedef wchar_t value_type;
	typedef const value_type* const_str;
	typedef value_type* pointer;
	typedef const value_type* const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	typedef pointer iterator;
	typedef const_pointer const_iterator;
	static const size_type MAX_SIZE = S;

	StringBuilderStackWT() : _parentType()
	{
	}

	StringBuilderStackWT(const _parentType& str) : _parentType(str)
	{
	}

	StringBuilderStackWT(const _parentType& str, size_type nOff, size_type nCount) : _parentType(str, nOff, nCount)
	{
	}

	StringBuilderStackWT(const _Self& str) : _parentType(str)
	{
	}

	StringBuilderStackWT(const _Self& str, size_type nOff, size_type nCount) : _parentType(str, nOff, nCount)
	{
	}

	StringBuilderStackWT(size_type nRepeat, value_type ch) : _parentType(nRepeat, ch)
	{
	}

	StringBuilderStackWT(const_str str) : _parentType(str)
	{
	}

	StringBuilderStackWT(const_str str, size_type nLength) : _parentType(str, nLength)
	{
	}

	StringBuilderStackWT(const_iterator _First, const_iterator _Last) : _parentType(_First, _Last)
	{
	}

	template <size_t AnySize>
	_Self& operator=(const StringBuilderStackWT<AnySize>& str)
	{
		_parentType::operator=(str);
		return *this;
	}

	template <size_t AnySize>
	_Self& operator=(const StackStringT<wchar_t, AnySize>& str)
	{
		_parentType::operator=(str);;
		return *this;
	}
};

typedef StringBuilderStackT<512>	fixed_string;
typedef StringBuilderStackWT<512>	fixed_wstring;
typedef StackStringT<char,		512> ANSI_PATH;
typedef StackStringT<wchar_t,	512> UNICODE_PATH;

typedef  StackStringT<char, 50>		ANSI_50;
typedef  StackStringT<wchar_t, 50>	UNICODE_50;