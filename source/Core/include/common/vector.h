#pragma once

#include <common/base_types.h>
#include <utility>
#include <iterator>

#include <initializer_list>
#include <common/mem.h>

#define LNI_VECTOR_MAX_SZ 1000000000


template <typename T>
class vector
{
public:
	// types:
	typedef T value_type;
	typedef T& reference;
	typedef const T& const_reference;
	typedef T* pointer;
	typedef const T* const_pointer;
	typedef T* iterator;
	typedef const T* const_iterator;
	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
	typedef ptrdiff_t difference_type;
	typedef unsigned int size_type;

	// 23.3.11.2, construct/copy/destroy:
	vector() noexcept;
	explicit vector(size_type n);
	vector(size_type n, const T& val);
	vector(typename iterator first, typename vector<T>::iterator last);
	vector(std::initializer_list<T>);
	vector(const vector<T>&);
	vector(vector<T>&&) noexcept;
	~vector();
	vector<T>& operator =(const vector<T>&);
	vector<T>& operator =(vector<T>&&) noexcept;
	vector<T>& operator =(std::initializer_list<T>);
	void assign(size_type, const T& value);
	void assign(iterator, iterator);
	void assign(std::initializer_list<T>);

	// iterators:
	iterator begin() noexcept;
	const_iterator cbegin() const noexcept;
	iterator end() noexcept;
	const_iterator cend() const noexcept;
	reverse_iterator rbegin() noexcept;
	const_reverse_iterator crbegin() const noexcept;
	reverse_iterator rend() noexcept;
	const_reverse_iterator crend() const noexcept;

	// 23.3.11.3, capacity:
	bool empty() const noexcept;
	size_type size() const noexcept;
	size_type max_size() const noexcept;
	size_type capacity() const noexcept;
	void resize(size_type);
	void resize(size_type, const T&);
	void reserve(size_type);
	void shrink_to_fit();

	// element access
	reference operator [](size_type);
	const_reference operator [](size_type) const;
	reference at(size_type);
	const_reference at(size_type) const;
	reference front();
	const_reference front() const;
	reference back();
	const_reference back() const;

	// 23.3.11.4, data access:
	T* data() noexcept;
	const T* data() const noexcept;

	// 23.3.11.5, modifiers:
	template <class ... Args>
	void emplace_back(Args&& ... args);
	void push_back(const T&);
	void push_back(T&&);
	void pop_back();

	template <class ... Args>
	iterator emplace(const_iterator, Args&& ...);
	iterator insert(const_iterator, const T&);
	iterator insert(const_iterator, T&&);
	iterator insert(const_iterator, size_type, const T&);
	template <class InputIt>
	iterator insert(const_iterator, InputIt, InputIt);
	iterator insert(const_iterator, std::initializer_list<T>);
	iterator erase(const_iterator);
	iterator erase(const_iterator, const_iterator);
	void swap(vector<T>&);
	void clear() noexcept;

	bool operator ==(const vector<T>&) const;
	bool operator !=(const vector<T>&) const;
	bool operator <(const vector<T>&) const;
	bool operator <=(const vector<T>&) const;
	bool operator >(const vector<T>&) const;
	bool operator >=(const vector<T>&) const;
private:
	size_type rsrv_sz = 4;
	size_type vec_sz = 0;
	T* arr_data_;

	inline void reallocate();
};


template <typename T>
vector<T>::vector() noexcept
{
	arr_data_ = new T[rsrv_sz];
}

template <typename T>
vector<T>::vector(typename vector<T>::size_type n)
{
	size_type i;
	rsrv_sz = n << 2;
	arr_data_ = new T[rsrv_sz];
	for (i = 0; i < n; ++i)
		arr_data_[i] = T();
	vec_sz = n;
}

template <typename T>
vector<T>::vector(typename vector<T>::size_type n, const T& value)
{
	size_type i;
	rsrv_sz = n << 2;
	arr_data_ = new T[rsrv_sz];
	for (i = 0; i < n; ++i)
		arr_data_[i] = value;
	vec_sz = n;
}

template <typename T>
vector<T>::vector(typename vector<T>::iterator first, typename vector<T>::iterator last)
{
	size_type i, count = last - first;
	rsrv_sz = count << 2;
	arr_data_ = new T[rsrv_sz];
	for (i = 0; i < count; ++i , ++first)
		arr_data_[i] = *first;
	vec_sz = count;
}

template <typename T>
vector<T>::vector(std::initializer_list<T> lst)
{
	rsrv_sz = lst.size() << 2;
	arr_data_ = new T[rsrv_sz];
	for (auto& item : lst)
		arr_data_[vec_sz++] = item;
}

template <typename T>
vector<T>::vector(const vector<T>& other)
{
	size_type i;
	rsrv_sz = other.rsrv_sz;
	arr_data_ = new T[rsrv_sz];
	for (i = 0; i < other.vec_sz; ++i)
		arr_data_[i] = other.arr_data_[i];
	vec_sz = other.vec_sz;
}

template <typename T>
vector<T>::vector(vector<T>&& other) noexcept
{
	size_type i;
	rsrv_sz = other.rsrv_sz;
	arr_data_ = new T[rsrv_sz];
	for (i = 0; i < other.vec_sz; ++i)
		arr_data_[i] = std::move(other.arr_data_[i]);
	vec_sz = other.vec_sz;
}

template <typename T>
vector<T>::~vector()
{
	delete[] arr_data_;
}

template <typename T>
vector<T>& vector<T>::operator =(const vector<T>& other)
{
	size_type i;
	if (rsrv_sz < other.vec_sz)
	{
		rsrv_sz = other.vec_sz << 2;
		reallocate();
	}
	for (i = 0; i < other.vec_sz; ++i)
		arr_data_[i] = other.arr_data_[i];
	vec_sz = other.vec_sz;
	return  this;
}

template <typename T>
vector<T>& vector<T>::operator =(vector<T>&& other) noexcept
{
	size_type i;
	if (rsrv_sz < other.vec_sz)
	{
		rsrv_sz = other.vec_sz << 2;
		reallocate();
	}

	for (i = 0; i < other.vec_sz; ++i)
		arr_data_[i] = std::move(other.arr_data_[i]);
	vec_sz = other.vec_sz;

	return  this;
}

template <typename T>
vector<T>& vector<T>::operator =(std::initializer_list<T> lst)
{
	if (rsrv_sz < lst.size())
	{
		rsrv_sz = lst.size() << 2;
		reallocate();
	}
	vec_sz = 0;

	for (auto& item : lst)
		arr_data_[vec_sz++] = item;

	return  this;
}

template <typename T>
void vector<T>::assign(typename vector<T>::size_type count, const T& value)
{
	size_type i;
	if (count > rsrv_sz)
	{
		rsrv_sz = count << 2;
		reallocate();
	}
	for (i = 0; i < count; ++i)
		arr_data_[i] = value;
	vec_sz = count;
}

template <typename T>
void vector<T>::assign(typename vector<T>::iterator first, typename vector<T>::iterator last)
{
	size_type i, count = last - first;
	if (count > rsrv_sz)
	{
		rsrv_sz = count << 2;
		reallocate();
	}
	for (i = 0; i < count; ++i , ++first)
		arr_data_[i] = *first;
	vec_sz = count;
}

template <typename T>
void vector<T>::assign(std::initializer_list<T> lst)
{
	size_type i, count = lst.size();
	if (count > rsrv_sz)
	{
		rsrv_sz = count << 2;
		reallocate();
	}
	i = 0;
	for (auto& item : lst)
		arr_data_[i++] = item;
}


template <typename T>
typename vector<T>::iterator vector<T>::begin() noexcept
{
	return arr_data_;
}

template <typename T>
typename vector<T>::const_iterator vector<T>::cbegin() const noexcept
{
	return arr_data_;
}

template <typename T>
typename vector<T>::iterator vector<T>::end() noexcept
{
	return arr_data_ + vec_sz;
}

template <typename T>
typename vector<T>::const_iterator vector<T>::cend() const noexcept
{
	return arr_data_ + vec_sz;
}

template <typename T>
typename vector<T>::reverse_iterator vector<T>::rbegin() noexcept
{
	return reverse_iterator(arr_data_ + vec_sz);
}

template <typename T>
typename vector<T>::const_reverse_iterator vector<T>::crbegin() const noexcept
{
	return reverse_iterator(arr_data_ + vec_sz);
}

template <typename T>
typename vector<T>::reverse_iterator vector<T>::rend() noexcept
{
	return reverse_iterator(arr_data_);
}

template <typename T>
typename vector<T>::const_reverse_iterator vector<T>::crend() const noexcept
{
	return reverse_iterator(arr_data_);
}


template <typename T>
inline void vector<T>::reallocate()
{
	T* tarr = new T[rsrv_sz];
	mem::memcpy(tarr, arr_data_, vec_sz * sizeof(T));
	delete[] arr_data_;
	arr_data_ = tarr;
}


template <typename T>
bool vector<T>::empty() const noexcept
{
	return vec_sz == 0;
}

template <typename T>
typename vector<T>::size_type vector<T>::size() const noexcept
{
	return vec_sz;
}

template <typename T>
typename vector<T>::size_type vector<T>::max_size() const noexcept
{
	return LNI_VECTOR_MAX_SZ;
}

template <typename T>
typename vector<T>::size_type vector<T>::capacity() const noexcept
{
	return rsrv_sz;
}

template <typename T>
void vector<T>::resize(typename vector<T>::size_type sz)
{
	if (sz > vec_sz)
	{
		if (sz > rsrv_sz)
		{
			rsrv_sz = sz;
			reallocate();
		}
	}
	else
	{
		size_type i;
		for (i = vec_sz; i < sz; ++i)
			arr_data_[i].~T();
	}
	vec_sz = sz;
}

template <typename T>
void vector<T>::resize(typename vector<T>::size_type sz, const T& c)
{
	if (sz > vec_sz)
	{
		if (sz > rsrv_sz)
		{
			rsrv_sz = sz;
			reallocate();
		}
		size_type i;
		for (i = vec_sz; i < sz; ++i)
			arr_data_[i] = c;
	}
	else
	{
		size_type i;
		for (i = vec_sz; i < sz; ++i)
			arr_data_[i].~T();
	}
	vec_sz = sz;
}

template <typename T>
void vector<T>::reserve(typename vector<T>::size_type _sz)
{
	if (_sz > rsrv_sz)
	{
		rsrv_sz = _sz;
		reallocate();
	}
}

template <typename T>
void vector<T>::shrink_to_fit()
{
	rsrv_sz = vec_sz;
	reallocate();
}


template <typename T>
typename vector<T>::reference vector<T>::operator [](typename vector<T>::size_type idx)
{
	return arr_data_[idx];
}

template <typename T>
typename vector<T>::const_reference vector<T>::operator [](typename vector<T>::size_type idx) const
{
	return arr_data_[idx];
}

template <typename T>
typename vector<T>::reference vector<T>::at(size_type pos)
{
	if (pos < vec_sz)
		return arr_data_[pos];
	else
		throw std::out_of_range("accessed position is out of range");
}

template <typename T>
typename vector<T>::const_reference vector<T>::at(size_type pos) const
{
	if (pos < vec_sz)
		return arr_data_[pos];
	else
		throw std::out_of_range("accessed position is out of range");
}

template <typename T>
typename vector<T>::reference vector<T>::front()
{
	return arr_data_[0];
}

template <typename T>
typename vector<T>::const_reference vector<T>::front() const
{
	return arr_data_[0];
}

template <typename T>
typename vector<T>::reference vector<T>::back()
{
	return arr_data_[vec_sz - 1];
}

template <typename T>
typename vector<T>::const_reference vector<T>::back() const
{
	return arr_data_[vec_sz - 1];
}


template <typename T>
T* vector<T>::data() noexcept
{
	return arr_data_;
}

template <typename T>
const T* vector<T>::data() const noexcept
{
	return arr_data_;
}


template <typename T>
template <class ... Args>
void vector<T>::emplace_back(Args&& ... args)
{
	if (vec_sz == rsrv_sz)
	{
		rsrv_sz <<= 2;
		reallocate();
	}
	arr_data_[vec_sz] = std::move(T(std::forward<Args>(args) ...));
	++vec_sz;
}

template <typename T>
void vector<T>::push_back(const T& val)
{
	if (vec_sz == rsrv_sz)
	{
		rsrv_sz <<= 2;
		reallocate();
	}
	arr_data_[vec_sz] = val;
	++vec_sz;
}

template <typename T>
void vector<T>::push_back(T&& val)
{
	if (vec_sz == rsrv_sz)
	{
		rsrv_sz <<= 2;
		reallocate();
	}
	arr_data_[vec_sz] = std::move(val);
	++vec_sz;
}

template <typename T>
void vector<T>::pop_back()
{
	--vec_sz;
	arr_data_[vec_sz].~T();
}


template <typename T>
template <class ... Args>
typename vector<T>::iterator vector<T>::emplace(typename vector<T>::const_iterator it, Args&& ... args)
{
	iterator iit = &arr_data_[it - arr_data_];
	if (vec_sz == rsrv_sz)
	{
		rsrv_sz <<= 2;
		reallocate();
	}
	mem::memmove(iit + 1, iit, (vec_sz - (it - arr_data_)) * sizeof(T));
	(*iit) = std::move(T(std::forward<Args>(args) ...));
	++vec_sz;
	return iit;
}

template <typename T>
typename vector<T>::iterator vector<T>::insert(typename vector<T>::const_iterator it, const T& val)
{
	iterator iit = &arr_data_[it - arr_data_];
	if (vec_sz == rsrv_sz)
	{
		rsrv_sz <<= 2;
		reallocate();
	}
	mem::memmove(iit + 1, iit, (vec_sz - (it - arr_data_)) * sizeof(T));
	(*iit) = val;
	++vec_sz;
	return iit;
}

template <typename T>
typename vector<T>::iterator vector<T>::insert(typename vector<T>::const_iterator it, T&& val)
{
	iterator iit = &arr_data_[it - arr_data_];
	if (vec_sz == rsrv_sz)
	{
		rsrv_sz <<= 2;
		reallocate();
	}
	mem::memmove(iit + 1, iit, (vec_sz - (it - arr_data_)) * sizeof(T));
	(*iit) = std::move(val);
	++vec_sz;
	return iit;
}

template <typename T>
typename vector<T>::iterator vector<T>::insert(typename vector<T>::const_iterator it, typename vector<T>::size_type cnt, const T& val)
{
	iterator f = &arr_data_[it - arr_data_];
	if (!cnt) return f;
	if (vec_sz + cnt > rsrv_sz)
	{
		rsrv_sz = (vec_sz + cnt) << 2;
		reallocate();
	}
	mem::memmove(f + cnt, f, (vec_sz - (it - arr_data_)) * sizeof(T));
	vec_sz += cnt;
	for (iterator it = f; cnt--; ++it)
		(*it) = val;
	return f;
}

template <typename T>
template <class InputIt>
typename vector<T>::iterator vector<T>::insert(typename vector<T>::const_iterator it, InputIt first, InputIt last)
{
	iterator f = &arr_data_[it - arr_data_];
	size_type cnt = last - first;
	if (!cnt) return f;
	if (vec_sz + cnt > rsrv_sz)
	{
		rsrv_sz = (vec_sz + cnt) << 2;
		reallocate();
	}
	mem::memmove(f + cnt, f, (vec_sz - (it - arr_data_)) * sizeof(T));
	for (iterator it = f; first != last; ++it , ++first)
		(*it) = *first;
	vec_sz += cnt;
	return f;
}

template <typename T>
typename vector<T>::iterator vector<T>::insert(typename vector<T>::const_iterator it, std::initializer_list<T> lst)
{
	size_type cnt = lst.size();
	iterator f = &arr_data_[it - arr_data_];
	if (!cnt) return f;
	if (vec_sz + cnt > rsrv_sz)
	{
		rsrv_sz = (vec_sz + cnt) << 2;
		reallocate();
	}
	mem::memmove(f + cnt, f, (vec_sz - (it - arr_data_)) * sizeof(T));
	iterator iit = f;
	for (auto& item : lst)
	{
		(*iit) = item;
		++iit;
	}
	vec_sz += cnt;
	return f;
}

template <typename T>
typename vector<T>::iterator vector<T>::erase(typename vector<T>::const_iterator it)
{
	iterator iit = &arr_data_[it - arr_data_];
	(*iit).~T();
	mem::memmove(iit, iit + 1, (vec_sz - (it - arr_data_) - 1) * sizeof(T));
	--vec_sz;
	return iit;
}

template <typename T>
typename vector<T>::iterator vector<T>::erase(typename vector<T>::const_iterator first, typename vector<T>::const_iterator last)
{
	iterator f = &arr_data_[first - arr_data_];
	if (first == last) return f;
	for (; first != last; ++first)
		(*first).~T();
	mem::memmove(f, last, (vec_sz - (last - arr_data_)) * sizeof(T));
	vec_sz -= last - first;
	return f;
}

template <typename T>
void vector<T>::swap(vector<T>& rhs)
{
	size_t tvec_sz = vec_sz,
		trsrv_sz = rsrv_sz;
	T* tarr = arr_data_;

	vec_sz = rhs.vec_sz;
	rsrv_sz = rhs.rsrv_sz;
	arr_data_ = rhs.arr_data_;

	rhs.vec_sz = tvec_sz;
	rhs.rsrv_sz = trsrv_sz;
	rhs.arr_data_ = tarr;
}

template <typename T>
void vector<T>::clear() noexcept
{
	size_type i;
	for (i = 0; i < vec_sz; ++i)
		arr_data_[i].~T();
	vec_sz = 0;
}


template <typename T>
bool vector<T>::operator ==(const vector<T>& rhs) const
{
	if (vec_sz != rhs.vec_sz) return false;
	size_type i;
	for (i = 0; i < vec_sz; ++i)
		if (arr_data_[i] != rhs.arr_data_[i])
			return false;
	return true;
}

template <typename T>
bool vector<T>::operator !=(const vector<T>& rhs) const
{
	if (vec_sz != rhs.vec_sz) return true;
	size_type i;
	for (i = 0; i < vec_sz; ++i)
		if (arr_data_[i] != rhs.arr_data_[i])
			return true;
	return false;
}

template <typename T>
bool vector<T>::operator <(const vector<T>& rhs) const
{
	size_type i, j, ub = vec_sz < rhs.vec_sz ? vec_sz : rhs.vec_sz;
	for (i = 0; i < ub; ++i)
		if (arr_data_[i] != rhs.arr_data_[i])
			return arr_data_[i] < rhs.arr_data_[i];
	return vec_sz < rhs.vec_sz;
}

template <typename T>
bool vector<T>::operator <=(const vector<T>& rhs) const
{
	size_type i, j, ub = vec_sz < rhs.vec_sz ? vec_sz : rhs.vec_sz;
	for (i = 0; i < ub; ++i)
		if (arr_data_[i] != rhs.arr_data_[i])
			return arr_data_[i] < rhs.arr_data_[i];
	return vec_sz <= rhs.vec_sz;
}

template <typename T>
bool vector<T>::operator >(const vector<T>& rhs) const
{
	size_type i, j, ub = vec_sz < rhs.vec_sz ? vec_sz : rhs.vec_sz;
	for (i = 0; i < ub; ++i)
		if (arr_data_[i] != rhs.arr_data_[i])
			return arr_data_[i] > rhs.arr_data_[i];
	return vec_sz > rhs.vec_sz;
}

template <typename T>
bool vector<T>::operator >=(const vector<T>& rhs) const
{
	size_type i, j, ub = vec_sz < rhs.vec_sz ? vec_sz : rhs.vec_sz;
	for (i = 0; i < ub; ++i)
		if (arr_data_[i] != rhs.arr_data_[i])
			return arr_data_[i] > rhs.arr_data_[i];
	return vec_sz >= rhs.vec_sz;
}

