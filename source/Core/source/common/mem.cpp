#include	<windows.h>
#include	<common/base_types.h>
#include	<common/mem.h>
#include	<common/DynamicCall.h>


#if defined MEM_ALLOC_SAFE_BYTES

#if defined _WIN64
#  define ADVANCED_ALLOC_BYTES 8
#else
#  define ADVANCED_ALLOC_BYTES 4
#endif

#else 
# define ADVANCED_ALLOC_BYTES 0
#endif


static HANDLE mainHeap = nullptr;
static int heapCreated = 0;


namespace mem
{

	bool Initialize(unsigned int size)
	{
		if (mainHeap != nullptr)
			return true;
		else
			mainHeap = API_KERNEL32(HeapCreate)(0, size, 0);

		return mainHeap != nullptr;
	}

	bool Initialize()
	{


		if ((mainHeap = API(KERNEL32, HeapCreate)(0, 0, 0)) != nullptr)
			return true;

		return false;
	}

	void* memcpy(void* dst, const void* src, size_t count)
	{
		void* ret = dst;
		// copy from lower addresses to higher addresses
		while (count--)
		{
			*(char *)dst = *(char *)src;
			dst = (char *)dst + 1;
			src = (char *)src + 1;
		}
		return (ret);
	}

	int memcmp(const void* buf1, const void* buf2, size_t count)
	{
		if (!count)
			return (0);

		while (--count && *(char *)buf1 == *(char *)buf2)
		{
			buf1 = (char *)buf1 + 1;
			buf2 = (char *)buf2 + 1;
		}

		return (*((unsigned char *)buf1) - *((unsigned char *)buf2));
	}

	void* memmove(void* dst, const void* src, size_t count)
	{
		void* ret = dst;

		if (dst <= src || (char *)dst >= ((char *)src + count))
		{
			memcpy(dst, src, count);
		}
		else
		{
			dst = (char *)dst + count - 1;
			src = (char *)src + count - 1;

			while (count--)
			{
				*(char *)dst = *(char *)src;
				dst = (char *)dst - 1;
				src = (char *)src - 1;
			}
		}

		return (ret);
	}

	int memmove_s(void* dst, size_t size_in_bytes, const void* src, size_t count)
	{
		if (count == 0) return 0;

		if (!dst) return 22;
		if (!src) return 22;
		if (size_in_bytes < count) return 34;
		mem::memmove(dst, src, count);

		return 0;
	}

	void* duplicate(const void* src, size_t count)
	{
		void* p = malloc(count);

		if (p != nullptr)
			mem::memmove(p, src, count);
		return p;
	}

	void* memset(void* dst, int val, size_t count)
	{
		void* start = dst;
		while (count--)
		{
			*(char *)dst = (char)val;
			dst = (char *)dst + 1;
		}
		return (start);
	}

	void memswap(void* mem1, void* mem2, size_t size)
	{
		BYTE tmp;
		LPBYTE b1 = (LPBYTE)mem1;
		LPBYTE b2 = (LPBYTE)mem2;

		if (mem1 != mem2)
			while (size--)
			{
				tmp = *b1;
				*b1++ = *b2;
				*b2++ = tmp;
			}
	}

	void* malloc(size_t size)
	{
		auto psize = size;

		if (psize == 0)  return nullptr;

		psize += ADVANCED_ALLOC_BYTES;

		return API_KERNEL32(HeapAlloc)(mainHeap, HEAP_ZERO_MEMORY, size);
	}

	void* realloc(void* p, size_t size)
	{
		if (size == 0)
			return nullptr;


		size += ADVANCED_ALLOC_BYTES;


		if (p)
			return API_KERNEL32(HeapReAlloc)(mainHeap, 0, p, size);
		else
			return API_KERNEL32(HeapAlloc)(mainHeap, HEAP_ZERO_MEMORY, size);
	}

	bool reallocEx(void* p, size_t size)
	{
		if (size == 0)
		{
			free(p);
			*static_cast<unsigned char **>(p) = nullptr;
		}
		else
		{
			auto pS = realloc(*static_cast<unsigned char **>(p), size);

			if (pS == nullptr) return false;

			*static_cast<unsigned char **>(p) = LPBYTE(pS);
		}

		return true;
	}

	void free(void* p)
	{
		if (p)
		{
			API_KERNEL32(HeapFree)(mainHeap, 0, p);
		}
	}

	void freeArrayOfPointers(void* mem, SIZE_T count)
	{
		if (mem && count)
		{
			auto p = static_cast<unsigned char **>(mem);
			while (count--)free(p[count]);
			free(p);
		}
	}

	void zero(void* mem, unsigned long size)
	{
		memset(mem, 0, size);
	}
}

void* operator new(size_t blocksize)
{
	return mem::malloc(blocksize);;
}

void* operator new[](size_t blocksize)
{
	return mem::malloc(blocksize);
}

void operator delete(void* block)
{
	if (block) mem::free(block);
}

void operator delete[](void* block)
{
	if (block)
		mem::free(block);
}
