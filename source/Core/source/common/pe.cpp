#include <common/base_types.h>
#include "common/pe.h"


#define IMAGE_SIZEOF_BASE_RELOCATION 8

namespace pe
{
	HMODULE GetImageBase(void* func)
	{
		SIZE_T addr = (func) ? SIZE_T(func) : SIZE_T(&GetImageBase);
		addr &= ~0xffff;

		for (;;)
		{
			PIMAGE_DOS_HEADER dosHeader = PIMAGE_DOS_HEADER(addr);
			if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE)
			{
				if (dosHeader->e_lfanew < 0x1000)
				{
					PIMAGE_NT_HEADERS header = PIMAGE_NT_HEADERS(&LPBYTE(addr)[dosHeader->e_lfanew]);
					if (header->Signature == IMAGE_NT_SIGNATURE)
						break;
				}
			}
			addr -= 0x10000;
		}
		return HMODULE(addr);
	}

	PIMAGE_OPTIONAL_HEADER GetOptionalHeader(HMODULE module)
	{
		SIZE_T step_1 = SIZE_T(module) + PIMAGE_DOS_HEADER(module)->e_lfanew;
		SIZE_T step_2 = sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER);
		LPVOID step3 = LPVOID(step_1 + step_2);
		PIMAGE_OPTIONAL_HEADER result = PIMAGE_OPTIONAL_HEADER(step3);
		return result;
	}

	DWORD GetSizeOfImage(HMODULE module)
	{
		DWORD sizeOfImagen = GetOptionalHeader(module)->SizeOfImage;
		return sizeOfImagen;
	}

	void ProcessRelocs(PIMAGE_BASE_RELOCATION reloc, SIZE_T imageBase, SIZE_T delta, DWORD relocSize)
	{
		if (relocSize <= 0) return;
		while (reloc->SizeOfBlock > 0)
		{
			SIZE_T va = imageBase + reloc->VirtualAddress;
			USHORT* relInfo = (USHORT*)((PBYTE)reloc + IMAGE_SIZEOF_BASE_RELOCATION);

			for (DWORD i = 0; i < (reloc->SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) / 2; i++, relInfo++)
			{
				int type = *relInfo >> 12;
				int offset = *relInfo & 0xfff;

				switch (type)
				{
				case IMAGE_REL_BASED_ABSOLUTE:
					break;
				case IMAGE_REL_BASED_HIGHLOW:
				case IMAGE_REL_BASED_DIR64:
					*((SIZE_T*)(va + offset)) += delta;
					break;
				}
			}
			reloc = (PIMAGE_BASE_RELOCATION)(((SIZE_T)reloc) + reloc->SizeOfBlock);
		}
	}
}









