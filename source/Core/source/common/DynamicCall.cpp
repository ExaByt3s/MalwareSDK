#include <windows.h>

#include <common/base_types.h>
#include <common/mem.h>
#include <common/str_traits.h>
#include "common/DynamicCall.h"
#include <common/pe.h>


static API_CALL_CACHE cache;
#define GET_DLL_NAME(name)  details::name##_DLL

namespace DynamicCall
{
	tGetProcAddress _GetProcAddress;
	tLoadLibraryA _LoadLibraryA;

	bool Initialize()
	{
		HMODULE kernel32;
		LP_API_CALL_CACHE lpcache = &cache;

		if ((kernel32 = GetDllBase(KERNERL32_MODULE_HASH)) == NULL)
			return false;


		DWORD GetprocessHash = str::to_hash("GetProcAddress", -1, false);
		DWORD LoadLibraryHash = str::to_hash("LoadLibraryA", -1, false);

		_GetProcAddress = reinterpret_cast<tGetProcAddress>(GetAdressOfAPI(kernel32, GetprocessHash));
		_LoadLibraryA = reinterpret_cast<tLoadLibraryA>(GetAdressOfAPI(kernel32, LoadLibraryHash));

		if ((_GetProcAddress == nullptr) || (_LoadLibraryA == nullptr))
			return false;

		mem::memset(lpcache->handle_hmodule, 0, sizeof(lpcache->handle_hmodule));
		mem::memset(lpcache->func_addr_table, 0, sizeof(lpcache->func_addr_table));
		mem::memset(lpcache->func_hash_table, 0, sizeof(lpcache->func_hash_table));

		lpcache->handle_hmodule[KERNEL32] = kernel32;
		return true;
	}

	PPEB GetPEB()
	{
#ifdef _WIN64
		return  (PPEB)__readgsqword(0x60);
#else
		PPEB PEB;
		__asm
		{
			mov eax, FS:[0x30]
			mov[PEB], eax
		}
		return PEB;
#endif
	}

	const char* GetModuleNameString(DWORD ID)
	{
		
		const char * name = nullptr;
		switch (ID)
		{
		case KERNEL32:	name = GET_DLL_NAME(KERNEL32);
		case NTDLL:		name = GET_DLL_NAME(NTDLL);
		case SHLWAPI:	name = GET_DLL_NAME(SHLWAPI);
		case URLMON:	name = GET_DLL_NAME(URLMON);
		case WINHTTP:	name = GET_DLL_NAME(WINHTTP);
		case WS2_32:	name = GET_DLL_NAME(WS2_32);
		case SHELL32:	name = GET_DLL_NAME(SHELL32);

		default: break;
		}
		
		return name;
	}

	HMODULE GetDllBase(DWORD hash)
	{
		PPEB Peb = GetPEB();
		PPEB_LDR_DATA LdrData = Peb->Ldr;
		PLIST_ENTRY Head = &LdrData->ModuleListLoadOrder;
		PLIST_ENTRY Entry = Head->Flink;

		do
		{
			PLDR_DATA_TABLE_ENTRY lr_data = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
			DWORD fucHash = 0;

			if (lr_data->BaseDllName.Length < 64)
				fucHash = str::to_hash(lr_data->BaseDllName.Buffer, -1, true);

			if (fucHash == hash)
				return HMODULE(lr_data->DllBase);

			Entry = Entry->Flink;
		} while (Entry != Head);

		return nullptr;
	}

	HMODULE GetKernel32()
	{
		HMODULE hkernel = nullptr;

		if (hkernel == nullptr)
			hkernel = GetDllBase(0x4B1FFE8E /* kernel32.dll */);

		return hkernel;
	}

	void* GetAdressOfAPI(HMODULE hModule, DWORD dwProcHash)
	{
		if (hModule == nullptr) return nullptr;
		PIMAGE_OPTIONAL_HEADER poh = pe::GetOptionalHeader(hModule);

		PIMAGE_EXPORT_DIRECTORY exportDir = (IMAGE_EXPORT_DIRECTORY*)((SIZE_T)hModule + (SIZE_T)poh->DataDirectory[0].VirtualAddress);

		int exportSize = poh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

		int ordinal = -1; // Номер необходимой нам функции

		DWORD* namesTable = (DWORD*)(SIZE_T(hModule) + SIZE_T(exportDir->AddressOfNames));
		WORD* ordinalTable = (WORD*)(SIZE_T(hModule) + (SIZE_T)exportDir->AddressOfNameOrdinals);

		for (UINT i = 0; i < exportDir->NumberOfNames; i++)
		{
			char* name = (char*)((SIZE_T)hModule + (SIZE_T)*namesTable);
			if (str::to_hash(name, -1, false) == dwProcHash)
			{
				ordinal = *ordinalTable;
				break;
			}
			// следующая функция
			namesTable++;
			ordinalTable++;
		}

		if (ordinal < 0)
			return nullptr;

		DWORD* addrTable = reinterpret_cast<DWORD*>(SIZE_T(hModule) + SIZE_T(exportDir->AddressOfFunctions));
		SIZE_T rva = addrTable[ordinal];

		SIZE_T addr = static_cast<SIZE_T>(SIZE_T(hModule) + SIZE_T(rva));

		if (addr > SIZE_T(exportDir) && addr < SIZE_T(exportDir) + exportSize)
		{
			char* s = reinterpret_cast<char*>(addr);
			char nameDll[32];
			mem::zero(nameDll, 32);
			PCCH lpstring = str::strchr(s, '.');
			mem::memcpy(nameDll, s, lpstring - s);
			str::strcat(nameDll, ".dll", 4);
			lpstring++;


			if (*lpstring == '#')
			{
				int num = 0;
				while (*++lpstring) num = num * 10 + *s - '0';
				s = reinterpret_cast<char*>(&num);
			}

			if (_LoadLibraryA == nullptr || _GetProcAddress == nullptr)
				DynamicCall::Initialize();

			HMODULE hdll = _LoadLibraryA(nameDll);
			return _GetProcAddress(hdll, lpstring);
		}
		else
		{
			return reinterpret_cast<void*>(addr);
		}
	}

	void* GetProcAddressEx(DWORD dwModule, DWORD dwProcHash)
	{
		int n = dwProcHash % MAX_API_TABLE;
		void* func = nullptr;
		HMODULE kernel32;
		HMODULE hmodule = nullptr;
		LP_API_CALL_CACHE lpcache = &cache;
		

		do
		{
			if (lpcache->func_hash_table[n] == dwProcHash)
				return lpcache->func_addr_table[n];

			n++;

			if (n >= MAX_API_TABLE) n = 0;

		} while (lpcache->func_hash_table[n]);

	
		if ((hmodule = lpcache->handle_hmodule[dwModule]) == nullptr)
		{
			const char* moduleName = GetModuleNameString(dwModule);
			hmodule = _LoadLibraryA(moduleName);
			lpcache->handle_hmodule[dwModule] = hmodule;
		}

		if (hmodule)
			func = GetAdressOfAPI(hmodule, dwProcHash);
		

		lpcache->func_hash_table[n] = dwProcHash;
		lpcache->func_addr_table[n] = func;

		return func;
	}

	bool BuildImportTable(HMODULE imageBase, tLoadLibraryA _LoadLibraryA, tGetProcAddress _GetProcAddress)
	{
		PIMAGE_DOS_HEADER dosHeader = PIMAGE_DOS_HEADER(imageBase);
		PIMAGE_NT_HEADERS headers = reinterpret_cast<PIMAGE_NT_HEADERS>(&PBYTE(imageBase)[dosHeader->e_lfanew]);
		PIMAGE_DATA_DIRECTORY directory = &headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

		if (directory->Size == 0) return true; //нет таблицы импорта
		if (directory->Size > 0xffff) return false;

		PIMAGE_IMPORT_DESCRIPTOR importDesc = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(SIZE_T(imageBase) + directory->VirtualAddress);

		for (; importDesc->Name; importDesc++)
		{
			SIZE_T *thunkRef, *funcRef;
			LPCSTR nameDll = (LPCSTR)((SIZE_T)imageBase + importDesc->Name);
			HMODULE handle = _LoadLibraryA(nameDll);

			if (handle == NULL) return false;

			if (importDesc->OriginalFirstThunk)
			{
				thunkRef = (SIZE_T*)((SIZE_T)imageBase + (DWORD)importDesc->OriginalFirstThunk);
				funcRef = (SIZE_T*)((SIZE_T)imageBase + (DWORD)importDesc->FirstThunk);
			}
			else
			{
				thunkRef = (SIZE_T*)((SIZE_T)imageBase + (DWORD)importDesc->FirstThunk);
				funcRef = (SIZE_T*)((SIZE_T)imageBase + (DWORD)importDesc->FirstThunk);
			}
			for (; *thunkRef; thunkRef++, funcRef++)
			{
				SIZE_T addr = 0;
				if
					IMAGE_SNAP_BY_ORDINAL(*thunkRef)
				{
					addr = (SIZE_T)_GetProcAddress(handle, (LPCSTR)IMAGE_ORDINAL(*thunkRef));
				}
				else
				{
					PIMAGE_IMPORT_BY_NAME thunkData = (PIMAGE_IMPORT_BY_NAME)((SIZE_T)imageBase + *thunkRef);
					addr = (SIZE_T)_GetProcAddress(handle, (LPCSTR)&thunkData->Name);
				}
				if (addr)
				{
					if (addr != *funcRef)
						*funcRef = addr;
				}
				else
				{
					return false;
				}
			}
		}
		return true;
	}

	bool InitializeImportsTable()
	{
		HMODULE imageBase = pe::GetImageBase(NULL);
		return BuildImportTable(imageBase, _LoadLibraryA, _GetProcAddress);
	}
}
