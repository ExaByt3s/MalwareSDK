#include "windows.h"
#include <common/mem.h>
#include <common/stream.h>
#include "common/str_traits.h"


MemDataStream::MemDataStream(int sz)
{
	if (sz > 0)
	{
		data = mem::malloc(sz);
		if (data) sz_data = sz;
		else sz_data = 0;
	}
	else
	{
		data = nullptr;
		sz_data = 0;
	}
	c_data = 0;
}

MemDataStream::~MemDataStream()
{
	mem::free(data);
}

MemDataStream::operator void*() const
{
	return data;
}

MemDataStream::operator char*() const
{
	return static_cast<char*>(data);
}

MemDataStream::operator unsigned char*() const
{
	return (unsigned char*)data;
}


bool MemDataStream::MakeEnough(int sz)
{
	if (sz_data - c_data >= sz) return true;
	int addSize = sz_data / 2;
	if (addSize < sz) addSize = sz;
	return reallocate(sz_data + addSize);
}

int MemDataStream::length() const
{
	return c_data;
}

int MemDataStream::set_length(int sz)
{
	if (sz < 0)
		c_data = 0;
	else if (sz > sz_data)
		c_data = sz_data;
	else
		c_data = sz;
	return c_data;
}

int MemDataStream::add_length(int add)
{
	c_data += add;
	if (c_data < 0)
		c_data = 0;
	else if (c_data > sz_data)
		c_data = sz_data;
	return c_data;
}

int MemDataStream::size() const
{
	return sz_data;
}

bool MemDataStream::append(const void* ptr, int c_ptr)
{
	if (MakeEnough(c_ptr))
	{
		mem::memcpy(LPBYTE(data) + c_data, ptr, c_ptr);
		c_data += c_ptr;
		return true;
	}
	return false;
}

bool MemDataStream::append(const char* s, int c_s)
{
	if (c_s < 0) c_s = str::strlen(s);

	if (s)
		return append(s, c_s + 1);
	else
	{
		char empty[1];
		empty[0] = 0;
		return append(empty, 1);
	}
}

bool MemDataStream::IsEnough(int sz)
{
	if (sz < sz_data - c_data)
		return true;
	return false;
}

void* MemDataStream::ptr_write()
{
	return PBYTE(data) + c_data;
}

void MemDataStream::clear()
{
	c_data = 0;
}

void MemDataStream::find_sub_mem(int index, int len)
{
	if (index >= 0)
	{
		if (index < c_data)
		{
			if (len > c_data - index) len = c_data - index;
			mem::memcpy(data, LPBYTE(data) + index, len);
			c_data = len;
		}
		else
		{
			c_data = 0;
		}
	}
}

void MemDataStream::find_sub_mem(MemDataStream& mem, int index, int len)
{
	if (index >= 0)
	{
		if (index < c_data)
		{
			if (len > c_data - index) len = c_data - index;
			mem.MakeEnough(len);
			mem::memcpy(mem.data, LPBYTE(data) + index, len);
			mem.c_data = len;
		}
		else
		{
			mem.c_data = 0;
		}
	}
}

bool MemDataStream::insert(int index, const void* ptr, int c_ptr)
{
	if (index < 0 || index > c_data || ptr == 0 || c_ptr < 0) return false;
	if (!MakeEnough(c_data + c_ptr)) return false;
	LPBYTE pd = (BYTE*)data;
	for (int from = c_data - 1, to = c_data + c_ptr - 1; from >= index; from-- , to--)
		pd[to] = pd[from];
	mem::memcpy(pd + index, ptr, c_ptr);
	c_data += c_ptr;
	return true;
}

bool MemDataStream::insert(int index, const MemDataStream& data)
{
	return insert(index, data, data.length());
}

void MemDataStream::remove(int index, int len)
{
	if (index < 0 || index >= c_data)
		return;
	if (index + len > c_data)
		len = c_data - index;

	mem::memcpy((BYTE*)data + index, (BYTE*)data + index + len, c_data - (index + len));
	c_data -= len;
}

void MemDataStream::left(int n)
{
	find_sub_mem(0, n);
}

void MemDataStream::Right(int n)
{
	find_sub_mem(c_data - n, n);
}

void MemDataStream::delete_left(int n)
{
	return Right(c_data - n);
}

void MemDataStream::delete_right(int n)
{
	return left(c_data - n);
}

void MemDataStream::set_full(char c)
{
	mem::memset(data, c, sz_data);
}

int MemDataStream::find_firts_of(int start, const void* what, int c_what)
{
	if (start < 0) start = 0;
	int res = find_index(LPBYTE(data) + start, c_data - start, what, c_what);
	if (res >= 0)
		res += start;
	return res;
}

int MemDataStream::find_firts_of(int start, char c)
{
	if (start < 0) start = 0;
	int res = find_index((LPBYTE*)data + start, c, c_data - start);
	if (res >= 0)
		res += start;
	return res;
}

int MemDataStream::find_firts_of(const void* what, int c_what)
{
	return find_index(data, c_data, what, c_what);
}

int MemDataStream::copy(const void* src, int c_src)
{
	if (!src || c_src <= 0) return 0;
	if (MakeEnough(c_src))
	{
		mem::memcpy(data, src, c_src);
		c_data = c_src;
		return c_src;
	}
	return 0;
}

int MemDataStream::copy(const MemDataStream& src)
{
	return copy(src.data, src.c_data);
}

int MemDataStream::copy(int dst_start, int src_start, int count, const void* src, int c_src)
{
	if (dst_start < 0) dst_start = 0;

	if (src_start < 0)
		src_start = 0;

	if (count < 0)
		count = 0;

	if (src_start + count > c_src)
		count = c_src - src_start;

	if (MakeEnough(dst_start + count))
	{
		mem::memcpy(LPBYTE(data) + dst_start, (LPBYTE)src + src_start, count);
		if (dst_start + count > c_data) c_data = dst_start + count;
		return count;
	}
	return 0;
}

int MemDataStream::copy(int start, const void* src, int c_src)
{
	return copy(start, 0, c_src, src, c_src);
}

int MemDataStream::copy(int dst_start, int src_start, int count, const MemDataStream& src)
{
	return copy(dst_start, src_start, count, src.data, src.c_data);
}

int MemDataStream::copy(int dst_start, int src_start, const MemDataStream& src)
{
	return copy(dst_start, src_start, src.c_data - src_start, src);
}

void* MemDataStream::unlink()
{
	void* ret = data;
	data = nullptr;
	c_data = 0;
	sz_data = 0;
	return ret;
}

void MemDataStream::link(MemDataStream& src)
{
	data = src.data;
	c_data = src.c_data;
	sz_data = src.sz_data;
}

void MemDataStream::link(void* _data, int _c_data)
{
	data = _data;
	c_data = _c_data;
	sz_data = _c_data;
}

int MemDataStream::replace(void* oldv, int c_oldv, void* newv, int c_newv)
{
	int p = 0, ret = 0;
	for (;;)
	{
		p = find_firts_of(p, oldv, c_oldv);
		if (p < 0) break;
		ret++;
		if (c_oldv >= c_newv)
		{
			mem::memcpy(LPBYTE(data) + p, newv, c_newv);
			p += c_newv;
			remove(p, c_oldv - c_newv);
		}
		else
		{
			mem::memcpy(LPBYTE(data) + p, newv, c_oldv);
			insert(p + c_oldv, LPBYTE(newv) + c_oldv, c_newv - c_oldv);
			p += c_newv;
		}
	}
	return ret;
}

bool MemDataStream::reallocate(int sz)
{
	if (sz < c_data) return false;
	void* newData = mem::realloc(data, sz);
	if (newData)
	{
		data = newData;
		sz_data = sz;
		return true;
	}
	return false;
}

int MemDataStream::find_index(const void* lpData, int nCount1, const void* lpData2, int ncount2)
{
	if (lpData == 0 || nCount1 <= 0 || lpData2 == nullptr || ncount2 <= 0) return -1;
	int index = -1;
	LPBYTE s = LPBYTE(lpData);
	LPBYTE sub = LPBYTE(lpData2);
	for (int i = 0; i <= nCount1 - ncount2; i++)
	{
		int j = 0;
		for (; j < ncount2; j++)
			if (s[i + j] != sub[j]) break;

		if (j >= ncount2)
		{
			index = i;
			break;
		}
	}
	return index;
}

int MemDataStream::find_index(const void* ptr, char c, int c_ptr)
{
	LPBYTE p = LPBYTE(find_index(ptr, c, c_ptr));
	if (p)
		return p - LPBYTE(ptr);
	return -1;
}
