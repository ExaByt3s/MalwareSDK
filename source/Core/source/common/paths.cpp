#include <windows.h>
#include <shlwapi.h>

#include <common/DynamicCall.h>
#include <common/mem.h>
#include <common/string.h>
#include <common/string_fixed.h>
#include <common/paths.h>


namespace paths
{

	bool GetKnownFolderPath(const KNOWNFOLDERID& rfid, DWORD dwFlags, wchar_t* ppszPath)
	{
		HRESULT result = S_FALSE;
		LPWSTR lpString;

		if ((result = fpSHGetKnownFolderPath(rfid, dwFlags, nullptr, &lpString)) == S_OK)
		{
			mem::memcpy(ppszPath, lpString, str::strlen(lpString) * sizeof(wchar_t));
			API_OLE32(CoTaskMemFree)(lpString);
		}

		return result == S_OK;
	}

	bool GetKnownFolderPath(const KNOWNFOLDERID& rfid, DWORD dwFlags, char* ppszPath)
	{
		HRESULT result = S_FALSE;
		LPWSTR lpString;

		if ((result = fpSHGetKnownFolderPath(rfid, dwFlags, nullptr, &lpString)) == S_OK)
		{
			str::unicodeToX(CP_ACP, lpString, -1, ppszPath, 512);
			API_OLE32(CoTaskMemFree)(lpString);
		}

		return result == S_OK;
	}

	bool GetKnownFolderPath(const KNOWNFOLDERID& rfid, DWORD dwFlags, UNICODE_PATH& lpPathString)
	{
		wchar_t* buffer = new wchar_t[512];
		bool isOK = false;

		if ((isOK = GetKnownFolderPath(ID_DESKTOP_FOLDER, 0, buffer)) != false)
			lpPathString = buffer;

		delete[]buffer;

		return isOK;
	}

	bool GetKnownFolderPath(const KNOWNFOLDERID& rfid, DWORD dwFlags, ANSI_PATH& lpPathString)
	{
		char* buffer = new char[512];
		bool isOK = false;

		if ((isOK = GetKnownFolderPath(ID_DESKTOP_FOLDER, 0, buffer)) != false)
			lpPathString = buffer;

		delete[]buffer;

		return isOK;
	}

	bool Append(char* pszPath, const char* pszMore)
	{
		return API_SHLWAPI(PathAppendA)(pszPath, pszPath) == TRUE;
	}

	bool Append(wchar_t* pszPath, const wchar_t* pszMore)
	{
		return API_SHLWAPI(PathAppendW)(pszPath, pszPath) == TRUE;
	}

	bool Combine(char* pszDest, const char* pszDir, const char* pszFile)
	{
		if (pszDir == nullptr && pszDir == nullptr && pszFile)
			return false;

		return API_SHLWAPI(PathCombineA)(pszDest, pszDir, pszFile) == NULL ? false : true;
	}

	bool Combine(wchar_t* pszDest, const wchar_t* pszDir, const wchar_t* pszFile)
	{
		if (pszDir == nullptr && pszDir == nullptr && pszFile)
			return false;

		return API_SHLWAPI(PathCombineW)(pszDest, pszDir, pszFile) == NULL ? false : true;
	}

	bool MakeFilePath(char* dest, const char* path, const char* file)
	{
		if ((dest == nullptr || path == nullptr || file == nullptr))
			return false;

		char* ext = FindExtension(file);

		if (((ext = FindExtension(file))) && *ext != '.')
			return false;


		return Combine(dest, path, file);
	}

	bool MakeFilePath(wchar_t* dest, const wchar_t* path, const wchar_t* file)
	{
		if ((dest == nullptr || path == nullptr || file == nullptr))
			return false;

		wchar_t* ext = FindExtension(file);

		if (((ext = FindExtension(file))) && *ext != '.')
			return false;

		if (Append(dest, path))
			return Append(dest, file);

		return true;
	}

	char* FindFileName(const char* pszPath)
	{
		return API(SHLWAPI, PathFindFileNameA)(pszPath);
	}

	wchar_t* FindFileName(const wchar_t* pszPath)
	{
		return API(SHLWAPI, PathFindFileNameW)(pszPath);
	}

	char* FindExtension(const char* path)
	{
		return API(SHLWAPI, PathFindExtensionA)(path);
	}

	wchar_t* FindExtension(const wchar_t* path)
	{
		return API(SHLWAPI, PathFindExtensionW)(path);
	}

	UNICODE_PATH& FindExtension(UNICODE_PATH& path)
	{
		const wchar_t* full = path;
		path = FindExtension(full);
		return path;
	}

	ANSI_PATH& FindExtension(ANSI_PATH& path)
	{
		const char* full = path;
		path = FindExtension(full);
		return path;
	}

	bool MatchSpec(const char* pszPath, const char* pszSpec)
	{
		bool result = API_SHLWAPI(PathMatchSpecA)(pszPath, pszSpec);
		return result == TRUE;
	}

	bool MatchSpec(const wchar_t* pszPath, const wchar_t* pszSpec)
	{
		bool result = API_SHLWAPI(PathMatchSpecW)(pszPath, pszSpec);
		return result == TRUE;
	}
}
